 # 力扣回溯问题分类总结

## 1. 组合问题

### 基本组合

```java

// 77. 组合
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    
    public List<List<Integer>> combine(int n, int k) {
        backtrack(new ArrayList<>(), 1, n, k);
        return result;
    }
    
    private void backtrack(List<Integer> path, int start, int n, int k) {
        if (path.size() == k) {
            result.add(new ArrayList<>(path));
            return;
        }
        
        for (int i = start; i <= n; i++) {
            path.add(i);
            backtrack(path, i + 1, n, k);
            path.remove(path.size() - 1);
        }
    }
}
```

### 组合总和

```java
// 39. 组合总和
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        Arrays.sort(candidates);
        backtrack(candidates, target, new ArrayList<>(), 0);
        return result;
    }
    
    private void backtrack(int[] candidates, int target, List<Integer> path, int start) {
        if (target == 0) {
            result.add(new ArrayList<>(path));
            return;
        }
        
        for (int i = start; i < candidates.length; i++) {
            if (candidates[i] > target) break;
            path.add(candidates[i]);
            backtrack(candidates, target - candidates[i], path, i); // 可重复使用
            path.remove(path.size() - 1);
        }
    }
}
```

### 组合总和II（去重）

```java
// 40. 组合总和 II
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        backtrack(candidates, target, new ArrayList<>(), 0);
        return result;
    }
    
    private void backtrack(int[] candidates, int target, List<Integer> path, int start) {
        if (target == 0) {
            result.add(new ArrayList<>(path));
            return;
        }
        
        for (int i = start; i < candidates.length; i++) {
            if (candidates[i] > target) break;
            if (i > start && candidates[i] == candidates[i - 1]) continue; // 去重
            
            path.add(candidates[i]);
            backtrack(candidates, target - candidates[i], path, i + 1);
            path.remove(path.size() - 1);
        }
    }
}
```

## 2. 排列问题

### 全排列

```java
// 46. 全排列
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    
    public List<List<Integer>> permute(int[] nums) {
        backtrack(nums, new ArrayList<>(), new boolean[nums.length]);
        return result;
    }
    
    private void backtrack(int[] nums, List<Integer> path, boolean[] used) {
        if (path.size() == nums.length) {
            result.add(new ArrayList<>(path));
            return;
        }
        
        for (int i = 0; i < nums.length; i++) {
            if (used[i]) continue;
            
            path.add(nums[i]);
            used[i] = true;
            backtrack(nums, path, used);
            used[i] = false;
            path.remove(path.size() - 1);
        }
    }
}
```

### 全排列II（去重）

```java
// 47. 全排列 II
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    
    public List<List<Integer>> permuteUnique(int[] nums) {
        Arrays.sort(nums);
        backtrack(nums, new ArrayList<>(), new boolean[nums.length]);
        return result;
    }
    
    private void backtrack(int[] nums, List<Integer> path, boolean[] used) {
        if (path.size() == nums.length) {
            result.add(new ArrayList<>(path));
            return;
        }
        
        for (int i = 0; i < nums.length; i++) {
            if (used[i] || (i > 0 && nums[i] == nums[i - 1] && !used[i - 1])) {
                continue; // 去重关键
            }
            
            path.add(nums[i]);
            used[i] = true;
            backtrack(nums, path, used);
            used[i] = false;
            path.remove(path.size() - 1);
        }
    }
}
```

## 3. 子集问题

### 子集

```java
// 78. 子集
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    
    public List<List<Integer>> subsets(int[] nums) {
        backtrack(nums, new ArrayList<>(), 0);
        return result;
    }
    
    private void backtrack(int[] nums, List<Integer> path, int start) {
        result.add(new ArrayList<>(path)); // 每个状态都是一个子集
        
        for (int i = start; i < nums.length; i++) {
            path.add(nums[i]);
            backtrack(nums, path, i + 1);
            path.remove(path.size() - 1);
        }
    }
}
```

### 子集II（去重）

```java
// 90. 子集 II
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        backtrack(nums, new ArrayList<>(), 0);
        return result;
    }
    
    private void backtrack(int[] nums, List<Integer> path, int start) {
        result.add(new ArrayList<>(path));
        
        for (int i = start; i < nums.length; i++) {
            if (i > start && nums[i] == nums[i - 1]) continue; // 去重
            
            path.add(nums[i]);
            backtrack(nums, path, i + 1);
            path.remove(path.size() - 1);
        }
    }
}
```

## 4. 分割问题

### 分割回文串

```java
// 131. 分割回文串
class Solution {
    List<List<String>> result = new ArrayList<>();
    
    public List<List<String>> partition(String s) {
        backtrack(s, new ArrayList<>(), 0);
        return result;
    }
    
    private void backtrack(String s, List<String> path, int start) {
        if (start == s.length()) {
            result.add(new ArrayList<>(path));
            return;
        }
        
        for (int i = start; i < s.length(); i++) {
            String substring = s.substring(start, i + 1);
            if (isPalindrome(substring)) {
                path.add(substring);
                backtrack(s, path, i + 1);
                path.remove(path.size() - 1);
            }
        }
    }
    
    private boolean isPalindrome(String s) {
        int left = 0, right = s.length() - 1;
        while (left < right) {
            if (s.charAt(left++) != s.charAt(right--)) {
                return false;
            }
        }
        return true;
    }
}
```

## 5. 棋盘问题

### N皇后

```java
// 51. N 皇后
class Solution {
    List<List<String>> result = new ArrayList<>();
    
    public List<List<String>> solveNQueens(int n) {
        char[][] board = new char[n][n];
        for (int i = 0; i < n; i++) {
            Arrays.fill(board[i], '.');
        }
        backtrack(board, 0);
        return result;
    }
    
    private void backtrack(char[][] board, int row) {
        if (row == board.length) {
            result.add(construct(board));
            return;
        }
        
        for (int col = 0; col < board.length; col++) {
            if (isValid(board, row, col)) {
                board[row][col] = 'Q';
                backtrack(board, row + 1);
                board[row][col] = '.';
            }
        }
    }
    
    private boolean isValid(char[][] board, int row, int col) {
        int n = board.length;
        
        // 检查列
        for (int i = 0; i < row; i++) {
            if (board[i][col] == 'Q') return false;
        }
        
        // 检查左上对角线
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
            if (board[i][j] == 'Q') return false;
        }
        
        // 检查右上对角线
        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
            if (board[i][j] == 'Q') return false;
        }
        
        return true;
    }
    
    private List<String> construct(char[][] board) {
        List<String> result = new ArrayList<>();
        for (char[] row : board) {
            result.add(new String(row));
        }
        return result;
    }
}
```

## 6. 其他经典问题

### 括号生成

```java
// 22. 括号生成
class Solution {
    List<String> result = new ArrayList<>();
    
    public List<String> generateParenthesis(int n) {
        backtrack(new StringBuilder(), 0, 0, n);
        return result;
    }
    
    private void backtrack(StringBuilder path, int open, int close, int n) {
        if (path.length() == n * 2) {
            result.add(path.toString());
            return;
        }
        
        if (open < n) {
            path.append('(');
            backtrack(path, open + 1, close, n);
            path.deleteCharAt(path.length() - 1);
        }
        
        if (close < open) {
            path.append(')');
            backtrack(path, open, close + 1, n);
            path.deleteCharAt(path.length() - 1);
        }
    }
}
```

### 单词搜索

```java
// 79. 单词搜索
class Solution {
    public boolean exist(char[][] board, String word) {
        int m = board.length, n = board[0].length;
        
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (backtrack(board, word, i, j, 0)) {
                    return true;
                }
            }
        }
        return false;
    }
    
    private boolean backtrack(char[][] board, String word, int i, int j, int index) {
        if (index == word.length()) return true;
        
        if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || 
            board[i][j] != word.charAt(index)) {
            return false;
        }
        
        char temp = board[i][j];
        board[i][j] = '#'; // 标记已访问
        
        boolean found = backtrack(board, word, i + 1, j, index + 1) ||
                       backtrack(board, word, i - 1, j, index + 1) ||
                       backtrack(board, word, i, j + 1, index + 1) ||
                       backtrack(board, word, i, j - 1, index + 1);
        
        board[i][j] = temp; // 回溯
        return found;
    }
}
```

## 回溯算法模板

```java
void backtrack(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtrack(路径，选择列表); // 递归
        回溯，撤销处理结果;
    }
}
```

## 关键技巧总结

1. **去重策略**：
   - 组合问题：`i > start && nums[i] == nums[i-1]`
   - 排列问题：`i > 0 && nums[i] == nums[i-1] && !used[i-1]`
2. **剪枝优化**：
   - 提前排序
   - 及时跳出循环
   - 状态检查
3. **状态管理**：
   - 使用visited数组
   - 原地修改后恢复
   - StringBuilder的使用

这些问题类型涵盖了力扣中90%以上的回溯问题，掌握这些模板和技巧即可应对大部分回溯算法题目。

找到具有 3 个许可证类型的类似代码
