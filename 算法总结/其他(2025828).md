根据您提供的文档，我将补充其他常见的LeetCode问题类型及解法：

## 一、字符串处理

### 1. 字符串匹配

```java
// KMP算法 - 字符串匹配
public int strStr(String haystack, String needle) {
    if (needle.isEmpty()) return 0;
    int[] lps = buildLPS(needle);
    int i = 0, j = 0;
    while (i < haystack.length()) {
        if (haystack.charAt(i) == needle.charAt(j)) {
            i++; j++;
        }
        if (j == needle.length()) return i - j;
        else if (i < haystack.length() && haystack.charAt(i) != needle.charAt(j)) {
            if (j != 0) j = lps[j - 1];
            else i++;
        }
    }
    return -1;
}
```

**思路**：构建部分匹配表，避免重复比较已匹配的字符。

### 2. 回文串判断

```java
// 验证回文串
public boolean isPalindrome(String s) {
    int left = 0, right = s.length() - 1;
    while (left < right) {
        while (left < right && !Character.isLetterOrDigit(s.charAt(left))) left++;
        while (left < right && !Character.isLetterOrDigit(s.charAt(right))) right--;
        if (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) {
            return false;
        }
        left++; right--;
    }
    return true;
}
```

**思路**：双指针从两端向中间靠拢，忽略非字母数字字符。

## 二、数学问题

### 1. 质数判断

```java
// 判断质数
public boolean isPrime(int n) {
    if (n <= 1) return false;
    if (n <= 3) return true;
    if (n % 2 == 0 || n % 3 == 0) return false;
    for (int i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0) return false;
    }
    return true;
}
```

**思路**：排除2和3的倍数，只检查6k±1形式的数。

### 2. 最大公约数

```java
// 欧几里得算法
public int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a % b);
}
```

**思路**：递归应用辗转相除法。

## 三、位运算

### 1. 位操作技巧

```java
// 只出现一次的数字
public int singleNumber(int[] nums) {
    int result = 0;
    for (int num : nums) {
        result ^= num;
    }
    return result;
}

// 计算二进制中1的个数
public int hammingWeight(int n) {
    int count = 0;
    while (n != 0) {
        count++;
        n &= (n - 1); // 清除最低位的1
    }
    return count;
}
```

**思路**：利用异或运算的性质和位操作技巧。

## 四、区间问题

### 1. 区间合并

```java
public int[][] merge(int[][] intervals) {
    Arrays.sort(intervals, (a, b) -> a[0] - b[0]);
    List<int[]> result = new ArrayList<>();
    
    for (int[] interval : intervals) {
        if (result.isEmpty() || result.get(result.size() - 1)[1] < interval[0]) {
            result.add(interval);
        } else {
            result.get(result.size() - 1)[1] = Math.max(result.get(result.size() - 1)[1], interval[1]);
        }
    }
    return result.toArray(new int[result.size()][]);
}
```

**思路**：先排序，然后逐个合并重叠区间。

## 五、栈和队列应用

### 1. 单调栈

```java
// 下一个更大元素
public int[] nextGreaterElement(int[] nums) {
    int[] result = new int[nums.length];
    Stack<Integer> stack = new Stack<>();
    
    for (int i = nums.length - 1; i >= 0; i--) {
        while (!stack.isEmpty() && stack.peek() <= nums[i]) {
            stack.pop();
        }
        result[i] = stack.isEmpty() ? -1 : stack.peek();
        stack.push(nums[i]);
    }
    return result;
}
```

**思路**：维护单调递减栈，从右向左遍历。

### 2. 队列实现栈

```java
class MyStack {
    Queue<Integer> queue;
    
    public void push(int x) {
        queue.offer(x);
        int size = queue.size();
        while (size > 1) {
            queue.offer(queue.poll());
            size--;
        }
    }
    
    public int pop() {
        return queue.poll();
    }
}
```

**思路**：每次入队后将前面的元素重新入队到末尾。

## 六、贪心算法

### 1. 活动选择问题

```java
// 无重叠区间
public int eraseOverlapIntervals(int[][] intervals) {
    Arrays.sort(intervals, (a, b) -> a[1] - b[1]);
    int count = 0, end = intervals[0][1];
    
    for (int i = 1; i < intervals.length; i++) {
        if (intervals[i][0] < end) {
            count++;
        } else {
            end = intervals[i][1];
        }
    }
    return count;
}
```

**思路**：按结束时间排序，贪心选择最早结束的活动。

## 七、并查集

### 1. 基本并查集

```java
class UnionFind {
    int[] parent, rank;
    
    public UnionFind(int n) {
        parent = new int[n];
        rank = new int[n];
        for (int i = 0; i < n; i++) parent[i] = i;
    }
    
    public int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]); // 路径压缩
        }
        return parent[x];
    }
    
    public void union(int x, int y) {
        int px = find(x), py = find(y);
        if (px == py) return;
        if (rank[px] < rank[py]) parent[px] = py;
        else if (rank[px] > rank[py]) parent[py] = px;
        else { parent[py] = px; rank[px]++; }
    }
}
```

**思路**：路径压缩和按秩合并优化查找和合并操作。

## 八、设计题

### 1. LRU缓存

```java
class LRUCache {
    class Node {
        int key, val;
        Node prev, next;
    }
    
    private Map<Integer, Node> cache = new HashMap<>();
    private Node head = new Node(), tail = new Node();
    private int capacity;
    
    public LRUCache(int capacity) {
        this.capacity = capacity;
        head.next = tail;
        tail.prev = head;
    }
    
    public int get(int key) {
        Node node = cache.get(key);
        if (node == null) return -1;
        moveToHead(node);
        return node.val;
    }
    
    public void put(int key, int value) {
        Node node = cache.get(key);
        if (node != null) {
            node.val = value;
            moveToHead(node);
        } else {
            node = new Node();
            node.key = key;
            node.val = value;
            cache.put(key, node);
            addToHead(node);
            if (cache.size() > capacity) {
                Node tail = removeTail();
                cache.remove(tail.key);
            }
        }
    }
}
```

**思路**：哈希表+双向链表，O(1)时间实现访问和更新。

## 九、矩阵问题

### 1. 螺旋遍历

```java
public List<Integer> spiralOrder(int[][] matrix) {
    List<Integer> result = new ArrayList<>();
    int top = 0, bottom = matrix.length - 1;
    int left = 0, right = matrix[0].length - 1;
    
    while (top <= bottom && left <= right) {
        for (int j = left; j <= right; j++) result.add(matrix[top][j]);
        top++;
        for (int i = top; i <= bottom; i++) result.add(matrix[i][right]);
        right--;
        if (top <= bottom) {
            for (int j = right; j >= left; j--) result.add(matrix[bottom][j]);
            bottom--;
        }
        if (left <= right) {
            for (int i = bottom; i >= top; i--) result.add(matrix[i][left]);
            left++;
        }
    }
    return result;
}
```

**思路**：维护四个边界，按顺时针方向逐层遍历。

## 十、概率与随机

### 1. 水塘抽样

```java
class Solution {
    Random random = new Random();
    
    public int getRandom(ListNode head) {
        int result = head.val;
        int count = 1;
        
        while (head.next != null) {
            head = head.next;
            count++;
            if (random.nextInt(count) == 0) {
                result = head.val;
            }
        }
        return result;
    }
}
```

**思路**：每个元素被选中的概率为1/n，动态维护选中的元素。