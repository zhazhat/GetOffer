根据面试中的常见情况，我将滑动窗口问题分为以下几个类型，并提供Java解法：

## 1. 固定窗口大小类

### 1.1 滑动窗口最大值

```java
public int[] maxSlidingWindow(int[] nums, int k) {
    Deque<Integer> deque = new ArrayDeque<>();
    int[] result = new int[nums.length - k + 1];
    
    for (int i = 0; i < nums.length; i++) {
        // 移除超出窗口的元素
        while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {
            deque.pollFirst();
        }
        // 维护单调递减队列
        while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
            deque.pollLast();
        }
        deque.offerLast(i);
        
        if (i >= k - 1) {
            result[i - k + 1] = nums[deque.peekFirst()];
        }
    }
    return result;
}
```

**思路：** 使用单调递减双端队列维护窗口内的最大值索引。

### 1.2 数组中所有长度为K的子数组平均值

```java
public double[] findMaxAverage(int[] nums, int k) {
    double sum = 0;
    for (int i = 0; i < k; i++) {
        sum += nums[i];
    }
    
    double maxSum = sum;
    for (int i = k; i < nums.length; i++) {
        sum = sum - nums[i - k] + nums[i];
        maxSum = Math.max(maxSum, sum);
    }
    
    return new double[]{maxSum / k};
}
```

**思路：** 先计算第一个窗口和，然后滑动时删除左边元素加上右边元素。

## 2. 可变窗口大小类

### 2.1 最长无重复字符子串

```java
public int lengthOfLongestSubstring(String s) {
    Map<Character, Integer> map = new HashMap<>();
    int left = 0, maxLen = 0;
    
    for (int right = 0; right < s.length(); right++) {
        char c = s.charAt(right);
        if (map.containsKey(c) && map.get(c) >= left) {
            left = map.get(c) + 1;
        }
        map.put(c, right);
        maxLen = Math.max(maxLen, right - left + 1);
    }
    
    return maxLen;
}
```

**思路：** 右指针扩展窗口，遇到重复字符时移动左指针到重复字符下一位。

### 2.2 最小覆盖子串

```java
public String minWindow(String s, String t) {
    Map<Character, Integer> need = new HashMap<>();
    Map<Character, Integer> window = new HashMap<>();
    
    for (char c : t.toCharArray()) {
        need.put(c, need.getOrDefault(c, 0) + 1);
    }
    
    int left = 0, right = 0;
    int valid = 0;
    int start = 0, len = Integer.MAX_VALUE;
    
    while (right < s.length()) {
        char c = s.charAt(right);
        right++;
        
        if (need.containsKey(c)) {
            window.put(c, window.getOrDefault(c, 0) + 1);
            if (window.get(c).equals(need.get(c))) {
                valid++;
            }
        }
        
        while (valid == need.size()) {
            if (right - left < len) {
                start = left;
                len = right - left;
            }
            
            char d = s.charAt(left);
            left++;
            
            if (need.containsKey(d)) {
                if (window.get(d).equals(need.get(d))) {
                    valid--;
                }
                window.put(d, window.get(d) - 1);
            }
        }
    }
    
    return len == Integer.MAX_VALUE ? "" : s.substring(start, start + len);
}
```

**思路：** 右指针扩展直到包含所有字符，然后左指针收缩找最小窗口。

### 2.3 长度最小的子数组（和大于等于target）

```java
public int minSubArrayLen(int target, int[] nums) {
    int left = 0, sum = 0;
    int minLen = Integer.MAX_VALUE;
    
    for (int right = 0; right < nums.length; right++) {
        sum += nums[right];
        
        while (sum >= target) {
            minLen = Math.min(minLen, right - left + 1);
            sum -= nums[left];
            left++;
        }
    }
    
    return minLen == Integer.MAX_VALUE ? 0 : minLen;
}
```

**思路：** 右指针扩展增加和，当和满足条件时左指针收缩寻找最小长度。

### 2.4 水果成篮（最多包含两种类型的最长子数组）

```java
public int totalFruit(int[] fruits) {
    Map<Integer, Integer> basket = new HashMap<>();
    int left = 0, maxLen = 0;
    
    for (int right = 0; right < fruits.length; right++) {
        basket.put(fruits[right], basket.getOrDefault(fruits[right], 0) + 1);
        
        while (basket.size() > 2) {
            basket.put(fruits[left], basket.get(fruits[left]) - 1);
            if (basket.get(fruits[left]) == 0) {
                basket.remove(fruits[left]);
            }
            left++;
        }
        
        maxLen = Math.max(maxLen, right - left + 1);
    }
    
    return maxLen;
}
```

**思路：** 维护最多包含两种元素的滑动窗口，超过两种时收缩左边界。

## 3. 字符串匹配类

### 3.1 找到字符串中所有字母异位词

```java
public List<Integer> findAnagrams(String s, String p) {
    List<Integer> result = new ArrayList<>();
    if (s.length() < p.length()) return result;
    
    int[] pCount = new int[26];
    int[] sCount = new int[26];
    
    for (char c : p.toCharArray()) {
        pCount[c - 'a']++;
    }
    
    int windowSize = p.length();
    for (int i = 0; i < s.length(); i++) {
        sCount[s.charAt(i) - 'a']++;
        
        if (i >= windowSize) {
            sCount[s.charAt(i - windowSize) - 'a']--;
        }
        
        if (Arrays.equals(pCount, sCount)) {
            result.add(i - windowSize + 1);
        }
    }
    
    return result;
}
```

**思路：** 维护固定长度窗口，比较字符频次数组判断是否为异位词。

### 3.2 字符串的排列

```java
public boolean checkInclusion(String s1, String s2) {
    if (s1.length() > s2.length()) return false;
    
    int[] s1Count = new int[26];
    int[] s2Count = new int[26];
    
    for (char c : s1.toCharArray()) {
        s1Count[c - 'a']++;
    }
    
    for (int i = 0; i < s2.length(); i++) {
        s2Count[s2.charAt(i) - 'a']++;
        
        if (i >= s1.length()) {
            s2Count[s2.charAt(i - s1.length()) - 'a']--;
        }
        
        if (Arrays.equals(s1Count, s2Count)) {
            return true;
        }
    }
    
    return false;
}
```

**思路：** 在s2中寻找长度等于s1且字符频次相同的子串。

## 4. 数值计算类

### 4.1 乘积小于K的子数组个数

```java
public int numSubarrayProductLessThanK(int[] nums, int k) {
    if (k <= 1) return 0;
    
    int left = 0, product = 1, count = 0;
    
    for (int right = 0; right < nums.length; right++) {
        product *= nums[right];
        
        while (product >= k) {
            product /= nums[left];
            left++;
        }
        
        count += right - left + 1;
    }
    
    return count;
}
```

**思路：** 右指针扩展，当乘积过大时左指针收缩，每次右指针位置贡献的子数组个数为right-left+1。

### 4.2 和为K的子数组个数（前缀和+哈希表）

```java
public int subarraySum(int[] nums, int k) {
    Map<Integer, Integer> prefixSum = new HashMap<>();
    prefixSum.put(0, 1);
    
    int sum = 0, count = 0;
    
    for (int num : nums) {
        sum += num;
        if (prefixSum.containsKey(sum - k)) {
            count += prefixSum.get(sum - k);
        }
        prefixSum.put(sum, prefixSum.getOrDefault(sum, 0) + 1);
    }
    
    return count;
}
```

**思路：** 使用前缀和，查找是否存在前缀和为sum-k的位置。

## 5. 特殊条件类

### 5.1 替换后的最长重复字符

```java
public int characterReplacement(String s, int k) {
    int[] count = new int[26];
    int left = 0, maxCount = 0, maxLen = 0;
    
    for (int right = 0; right < s.length(); right++) {
        maxCount = Math.max(maxCount, ++count[s.charAt(right) - 'A']);
        
        if (right - left + 1 - maxCount > k) {
            count[s.charAt(left) - 'A']--;
            left++;
        }
        
        maxLen = Math.max(maxLen, right - left + 1);
    }
    
    return maxLen;
}
```

**思路：** 维护窗口内出现最多的字符次数，当需要替换的字符数超过k时收缩窗口。

### 5.2 至多包含K个不同字符的最长子串

```java
public int lengthOfLongestSubstringKDistinct(String s, int k) {
    if (k == 0) return 0;
    
    Map<Character, Integer> window = new HashMap<>();
    int left = 0, maxLen = 0;
    
    for (int right = 0; right < s.length(); right++) {
        char c = s.charAt(right);
        window.put(c, window.getOrDefault(c, 0) + 1);
        
        while (window.size() > k) {
            char leftChar = s.charAt(left);
            window.put(leftChar, window.get(leftChar) - 1);
            if (window.get(leftChar) == 0) {
                window.remove(leftChar);
            }
            left++;
        }
        
        maxLen = Math.max(maxLen, right - left + 1);
    }
    
    return maxLen;
}
```

**思路：** 用哈希表记录窗口内字符种类，超过k种时收缩左边界。

## 6. 滑动窗口算法模板

```java
// 滑动窗口算法框架
public void slidingWindow(String s, String t) {
    Map<Character, Integer> need = new HashMap<>();
    Map<Character, Integer> window = new HashMap<>();
    
    for (char c : t.toCharArray()) {
        need.put(c, need.getOrDefault(c, 0) + 1);
    }
    
    int left = 0, right = 0;
    int valid = 0; // 窗口中满足need条件的字符个数
    
    while (right < s.length()) {
        // c 是将移入窗口的字符
        char c = s.charAt(right);
        // 右移窗口
        right++;
        // 进行窗口内数据的一系列更新
        
        // 判断左侧窗口是否要收缩
        while (window needs shrink) {
            // d 是将移出窗口的字符
            char d = s.charAt(left);
            // 左移窗口
            left++;
            // 进行窗口内数据的一系列更新
        }
    }
}
```

**核心思想：** 

1. 右指针扩展窗口寻找可行解
2. 左指针收缩窗口优化解
3. 在扩展和收缩过程中更新答案

这些题型涵盖了面试中95%以上的滑动窗口问题，掌握这些模式和模板可以快速解决相关问题。

找到具有 3 个许可证类型的类似代码
