## 1. 区间问题

### 1.1 区间调度问题

**典型题目：** 435. 无重叠区间、452. 用最少数量的箭引爆气球

**解法思路：** 按区间结束时间排序，贪心选择最早结束的区间（选择最早结束的区间，为后续留出最大可能空间。）

```java
// 435. 无重叠区间- 求最少删除数量
public int eraseOverlapIntervals(int[][] intervals) {
    if (intervals.length == 0) return 0;
    
    // 按结束时间排序
    Arrays.sort(intervals, (a, b) -> a[1] - b[1]);
    
    int count = 1; // 不重叠区间数量
    int end = intervals[0][1];
    
    for (int i = 1; i < intervals.length; i++) {
        if (intervals[i][0] >= end) {
            count++;
            end = intervals[i][1];
        }
    }
    
    return intervals.length - count;
}
```

### 1.2 区间合并问题

**典型题目：** 56. 合并区间：按起始时间排序后，从左到右处理，便于判断重叠和合并

```java
public int[][] merge(int[][] intervals) {
    if (intervals.length <= 1) return intervals;
    
    // 按起始时间排序
    Arrays.sort(intervals, (a, b) -> a[0] - b[0]);
    
    List<int[]> result = new ArrayList<>();
    int[] current = intervals[0];
    
    for (int i = 1; i < intervals.length; i++) {
        if (intervals[i][0] <= current[1]) {
            // 重叠，合并
            current[1] = Math.max(current[1], intervals[i][1]);
        } else {
            // 不重叠，添加当前区间
            result.add(current);
            current = intervals[i];
        }
    }
    result.add(current);
    
    return result.toArray(new int[result.size()][]);
}
```

## 2. 排序贪心

### 2.1 最大/最小数字构造

**典型题目：** 406. 根据身高重建队列([身高]\[有多少身高更高或相同的人在前面])

思路：根据身高从高到矮排序(身高相同则按照k值即插入位置升序排序)，而后根据k值插入对应位置

```java
public int[][] reconstructQueue(int[][] people) {
    // 按身高降序，k值升序排序
    Arrays.sort(people, (a, b) -> {
        if (a[0] != b[0]) return b[0] - a[0];
        return a[1] - b[1];
    });
    
    List<int[]> result = new ArrayList<>();
    
    // 按k值插入对应位置
    for (int[] person : people) {
        result.add(person[1], person);
    }
    
    return result.toArray(new int[result.size()][]);
}
```

### 2.2 分发问题

**典型题目：** 455. 分发饼干

```java
public int findContentChildren(int[] g, int[] s) {
    Arrays.sort(g); // 胃口排序
    Arrays.sort(s); // 饼干大小排序
    
    int child = 0;
    int cookie = 0;
    
    while (child < g.length && cookie < s.length) {
        if (s[cookie] >= g[child]) {
            child++; // 满足当前孩子
        }
        cookie++;
    }
    
    return child;
}
```

## 3. 股票买卖问题

### 3.1 买卖股票的最佳时机II

**典型题目：** 122. 买卖股票的最佳时机II

```java
public int maxProfit(int[] prices) {
    int profit = 0;
    
    for (int i = 1; i < prices.length; i++) {
        // 只要第二天价格高于第一天，就交易
        if (prices[i] > prices[i - 1]) {
            profit += prices[i] - prices[i - 1];
        }
    }
    
    return profit;
}
```

## 4. 跳跃游戏

### 4.1 跳跃游戏I

**典型题目：** 55. 跳跃游戏

```java
public boolean canJump(int[] nums) {
    int maxReach = 0;
    
    for (int i = 0; i < nums.length; i++) {
        if (i > maxReach) return false;
        maxReach = Math.max(maxReach, i + nums[i]);
    }
    
    return true;
}
```

### 4.2 跳跃游戏II

**典型题目：** 45. 跳跃游戏II

==维护能到达的最远位置索引以及下一次跳跃的终点==

```java
public int jump(int[] nums) {
    int jumps = 0;
    int currentEnd = 0;
    int farthest = 0;
    
    for (int i = 0; i < nums.length - 1; i++) {
        farthest = Math.max(farthest, i + nums[i]);
        
        if (i == currentEnd) {
            jumps++;
            currentEnd = farthest;
        }
    }
    
    return jumps;
}
```

## 5. 字符串问题

### 5.1 删除字符构造字典序最小

**典型题目：** 402. 移掉K位数字

```java
public String removeKdigits(String num, int k) {
    Stack<Character> stack = new Stack<>();
    
    for (char c : num.toCharArray()) {
        while (!stack.isEmpty() && k > 0 && stack.peek() > c) {
            stack.pop();
            k--;
        }
        stack.push(c);
    }
    
    // 如果还需要删除
    while (k > 0) {
        stack.pop();
        k--;
    }
    
    // 构建结果
    StringBuilder sb = new StringBuilder();
    for (char c : stack) {
        sb.append(c);
    }
    
    // 去除前导0
    while (sb.length() > 1 && sb.charAt(0) == '0') {
        sb.deleteCharAt(0);
    }
    
    return sb.length() == 0 ? "0" : sb.toString();
}
```

### 5.2 单调栈问题

**典型题目：** 316. 去除重复字母

```java
public String removeDuplicateLetters(String s) {
    int[] count = new int[26];
    boolean[] inStack = new boolean[26];
    
    // 统计每个字符出现次数
    for (char c : s.toCharArray()) {
        count[c - 'a']++;
    }
    
    Stack<Character> stack = new Stack<>();
    
    for (char c : s.toCharArray()) {
        count[c - 'a']--;
        
        if (inStack[c - 'a']) continue;
        
        // 如果栈顶元素大于当前字符且后面还会出现，则弹出
        while (!stack.isEmpty() && stack.peek() > c && count[stack.peek() - 'a'] > 0) {
            char top = stack.pop();
            inStack[top - 'a'] = false;
        }
        
        stack.push(c);
        inStack[c - 'a'] = true;
    }
    
    StringBuilder sb = new StringBuilder();
    for (char c : stack) {
        sb.append(c);
    }
    
    return sb.toString();
}
```

## 6. 加油站问题

**典型题目：** 134. 加油站

```java
public int canCompleteCircuit(int[] gas, int[] cost) {
    int totalTank = 0;
    int currTank = 0;
    int startStation = 0;
    
    for (int i = 0; i < gas.length; i++) {
        totalTank += gas[i] - cost[i];
        currTank += gas[i] - cost[i];
        
        // 如果当前油箱为负，从下一个站点重新开始
        if (currTank < 0) {
            startStation = i + 1;
            currTank = 0;
        }
    }
    
    return totalTank >= 0 ? startStation : -1;
}
```

## 7. 会议室问题

**典型题目：** 253. 会议室II（需要会员）

```java
public int minMeetingRooms(int[][] intervals) {
    if (intervals.length == 0) return 0;
    
    // 分别记录开始时间和结束时间
    int[] starts = new int[intervals.length];
    int[] ends = new int[intervals.length];
    
    for (int i = 0; i < intervals.length; i++) {
        starts[i] = intervals[i][0];
        ends[i] = intervals[i][1];
    }
    
    Arrays.sort(starts);
    Arrays.sort(ends);
    
    int rooms = 0;
    int endIdx = 0;
    
    for (int i = 0; i < starts.length; i++) {
        // 如果当前会议开始时间早于最早结束的会议，需要新房间
        if (starts[i] < ends[endIdx]) {
            rooms++;
        } else {
            endIdx++;
        }
    }
    
    return rooms;
}
```

## 总结

贪心算法的核心思想是**局部最优选择导致全局最优解**。常见的贪心策略包括：

1. **排序贪心**：先排序再贪心选择
2. **区间问题**：按起始/结束时间排序
3. **单调栈/队列**：维护单调性进行贪心选择
4. **两端贪心**：从两端向中间贪心
5. **计数贪心**：基于频次进行贪心选择

**解题关键**：

- 找到贪心策略的正确性证明
- 选择合适的排序方式
- 理解问题的本质，找到局部最优的判断标准