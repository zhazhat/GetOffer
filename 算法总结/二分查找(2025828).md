根据力扣中的二分查找问题，我将其分类总结如下：

## 1. 基础二分查找

### 704. 二分查找

**思路**：在有序数组中查找目标值的标准二分模板。

```java
public int search(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) return mid;
        else if (nums[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return -1;
}
```

### 35. 搜索插入位置

**思路**：找到第一个大于等于target的位置。

```java
public int searchInsert(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return left;
}
```

## 2. 查找边界问题

### 34. 在排序数组中查找元素的第一个和最后一个位置

**思路**：分别用二分查找左边界和右边界。

```java
public int[] searchRange(int[] nums, int target) {
    int left = findLeft(nums, target);
    int right = findRight(nums, target);
    return new int[]{left, right};
}

private int findLeft(int[] nums, int target) {
    int left = 0, right = nums.length - 1, res = -1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            res = mid;
            right = mid - 1;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return res;
}

private int findRight(int[] nums, int target) {
    int left = 0, right = nums.length - 1, res = -1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            res = mid;
            left = mid + 1;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return res;
}
```

## 3. 旋转数组问题

### 33. 搜索旋转排序数组

**思路**：先判断哪一半有序，再判断target在有序的一半还是无序的一半。

```java
public int search(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) return mid;
        
        if (nums[left] <= nums[mid]) { // 左半部分有序
            if (nums[left] <= target && target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        } else { // 右半部分有序
            if (nums[mid] < target && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }
    return -1;
}
```

### 81. 搜索旋转排序数组 II

**思路**：与33题类似，但需要处理重复元素，无法判断有序时移动边界。

```java
public boolean search(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) return true;
        
        if (nums[left] == nums[mid] && nums[mid] == nums[right]) {
            left++;
            right--;
        } else if (nums[left] <= nums[mid]) {
            if (nums[left] <= target && target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        } else {
            if (nums[mid] < target && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }
    return false;
}
```

### 153. 寻找旋转排序数组中的最小值

**思路**：比较mid与right的值，决定搜索方向。

```java
public int findMin(int[] nums) {
    int left = 0, right = nums.length - 1;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] > nums[right]) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return nums[left];
}
```

## 4. 山峰数组问题

### 162. 寻找峰值

**思路**：比较mid与mid+1的值，向上坡方向搜索。

```java
public int findPeakElement(int[] nums) {
    int left = 0, right = nums.length - 1;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] > nums[mid + 1]) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;
}
```

### 852. 山脉数组的峰顶索引

**思路**：在山脉数组中找峰值，比较mid与mid+1确定搜索方向。

```java
public int peakIndexInMountainArray(int[] arr) {
    int left = 0, right = arr.length - 1;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] < arr[mid + 1]) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}
```

## 5. 答案二分查找

### 69. x的平方根

**思路**：在[0, x]范围内二分查找最大的平方小于等于x的数。

```java
public int mySqrt(int x) {
    int left = 0, right = x, res = 0;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if ((long)mid * mid <= x) {
            res = mid;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return res;
}
```

### 367. 有效的完全平方数

**思路**：二分查找判断是否存在整数的平方等于num。

```java
public boolean isPerfectSquare(int num) {
    int left = 1, right = num;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        long square = (long)mid * mid;
        if (square == num) return true;
        else if (square < num) left = mid + 1;
        else right = mid - 1;
    }
    return false;
}
```

### 875. 爱吃香蕉的珂珂

**思路**：二分查找最小的吃香蕉速度，使得在h小时内能吃完所有香蕉。

```java
public int minEatingSpeed(int[] piles, int h) {
    int left = 1, right = Arrays.stream(piles).max().getAsInt();
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (canEatAll(piles, mid, h)) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;
}

private boolean canEatAll(int[] piles, int speed, int h) {
    int hours = 0;
    for (int pile : piles) {
        hours += (pile + speed - 1) / speed;
    }
    return hours <= h;
}
```

### 1011. 在D天内送达包裹的能力

**思路**：二分查找最小的船载重量，使得能在D天内运完所有货物。

```java
public int shipWithinDays(int[] weights, int days) {
    int left = Arrays.stream(weights).max().getAsInt();
    int right = Arrays.stream(weights).sum();
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (canShip(weights, mid, days)) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;
}

private boolean canShip(int[] weights, int capacity, int days) {
    int need = 1, cur = 0;
    for (int weight : weights) {
        if (cur + weight > capacity) {
            need++;
            cur = weight;
        } else {
            cur += weight;
        }
    }
    return need <= days;
}
```

## 6. 特殊数组问题

### 278. 第一个错误的版本

**思路**：二分查找第一个返回true的版本。

```java
public int firstBadVersion(int n) {
    int left = 1, right = n;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (isBadVersion(mid)) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;
}
```

### 374. 猜数字大小

**思路**：标准二分查找，根据guess的返回值调整搜索范围。

```java
public int guessNumber(int n) {
    int left = 1, right = n;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        int res = guess(mid);
        if (res == 0) return mid;
        else if (res == -1) right = mid - 1;
        else left = mid + 1;
    }
    return -1;
}
```

## 7. 矩阵二分查找

### 74. 搜索二维矩阵

**思路**：将二维矩阵看作一维有序数组进行二分查找。

```java
public boolean searchMatrix(int[][] matrix, int target) {
    int m = matrix.length, n = matrix[0].length;
    int left = 0, right = m * n - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        int midVal = matrix[mid / n][mid % n];
        if (midVal == target) return true;
        else if (midVal < target) left = mid + 1;
        else right = mid - 1;
    }
    return false;
}
```

### 240. 搜索二维矩阵 II

**思路**：从右上角开始搜索，利用矩阵的有序性质。

```java
public boolean searchMatrix(int[][] matrix, int target) {
    int row = 0, col = matrix[0].length - 1;
    while (row < matrix.length && col >= 0) {
        if (matrix[row][col] == target) return true;
        else if (matrix[row][col] > target) col--;
        else row++;
    }
    return false;
}
```

这些问题涵盖了力扣中最常见的二分查找类型，掌握这些模板和思路可以解决大部分二分查找相关问题。

找到具有 3 个许可证类型的类似代码
