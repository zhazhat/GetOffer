根据面试中的常见情况，我将单调栈/队列问题分类总结如下：

## 一、单调栈问题

### 1. 下一个更大/更小元素类

#### 739. 每日温度

```java
public int[] dailyTemperatures(int[] temperatures) {
    int n = temperatures.length;
    int[] result = new int[n];
    Deque<Integer> stack = new ArrayDeque<>();
    
    for (int i = 0; i < n; i++) {
        while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {
            int idx = stack.pop();
            result[idx] = i - idx;
        }
        stack.push(i);
    }
    return result;
}
```

**思路**：单调递减栈存储索引，遇到更大元素时弹出并计算距离。

#### 496. 下一个更大元素 I

```java
public int[] nextGreaterElement(int[] nums1, int[] nums2) {
    Map<Integer, Integer> map = new HashMap<>();
    Deque<Integer> stack = new ArrayDeque<>();
    
    for (int num : nums2) {
        while (!stack.isEmpty() && num > stack.peek()) {
            map.put(stack.pop(), num);
        }
        stack.push(num);
    }
    
    int[] result = new int[nums1.length];
    for (int i = 0; i < nums1.length; i++) {
        result[i] = map.getOrDefault(nums1[i], -1);
    }
    return result;
}
```

**思路**：先用单调栈处理nums2建立映射关系，再查询nums1的结果。

#### 503. 下一个更大元素 II（循环数组）

```java
public int[] nextGreaterElements(int[] nums) {
    int n = nums.length;
    int[] result = new int[n];
    Arrays.fill(result, -1);
    Deque<Integer> stack = new ArrayDeque<>();
    
    for (int i = 0; i < 2 * n; i++) {
        while (!stack.isEmpty() && nums[i % n] > nums[stack.peek()]) {
            result[stack.pop()] = nums[i % n];
        }
        if (i < n) stack.push(i);
    }
    return result;
}
```

**思路**：遍历两遍数组模拟循环，用取模操作处理索引。

### 2. 直方图最大面积类

#### 84. 柱状图中最大的矩形

```java
public int largestRectangleArea(int[] heights) {
    Deque<Integer> stack = new ArrayDeque<>();
    int maxArea = 0;
    
    for (int i = 0; i <= heights.length; i++) {
        int h = i == heights.length ? 0 : heights[i];
        while (!stack.isEmpty() && h < heights[stack.peek()]) {
            int height = heights[stack.pop()];
            int width = stack.isEmpty() ? i : i - stack.peek() - 1;
            maxArea = Math.max(maxArea, height * width);
        }
        stack.push(i);
    }
    return maxArea;
}
```

**思路**：单调递增栈，遇到更小元素时计算以栈顶为高度的最大矩形面积。

#### 85. 最大矩形

```java
public int maximalRectangle(char[][] matrix) {
    if (matrix.length == 0) return 0;
    int[] heights = new int[matrix[0].length];
    int maxArea = 0;
    
    for (char[] row : matrix) {
        for (int i = 0; i < row.length; i++) {
            heights[i] = row[i] == '1' ? heights[i] + 1 : 0;
        }
        maxArea = Math.max(maxArea, largestRectangleArea(heights));
    }
    return maxArea;
}
```

**思路**：转化为多个柱状图问题，每行更新高度数组后求最大矩形。

### 3. 去除元素类

#### 316. 去除重复字母

```java
public String removeDuplicateLetters(String s) {
    int[] count = new int[26];
    boolean[] inStack = new boolean[26];
    for (char c : s.toCharArray()) count[c - 'a']++;
    
    Deque<Character> stack = new ArrayDeque<>();
    for (char c : s.toCharArray()) {
        count[c - 'a']--;
        if (inStack[c - 'a']) continue;
        
        while (!stack.isEmpty() && stack.peek() > c && count[stack.peek() - 'a'] > 0) {
            inStack[stack.pop() - 'a'] = false;
        }
        stack.push(c);
        inStack[c - 'a'] = true;
    }
    
    StringBuilder sb = new StringBuilder();
    while (!stack.isEmpty()) sb.append(stack.removeLast());
    return sb.toString();
}
```

**思路**：单调递增栈，贪心地保留字典序最小的结果，用计数确保后续还有机会。

#### 402. 移掉K位数字

```java
public String removeKdigits(String num, int k) {
    Deque<Character> stack = new ArrayDeque<>();
    
    for (char c : num.toCharArray()) {
        while (!stack.isEmpty() && k > 0 && stack.peek() > c) {
            stack.pop();
            k--;
        }
        stack.push(c);
    }
    
    while (k > 0) {
        stack.pop();
        k--;
    }
    
    StringBuilder sb = new StringBuilder();
    while (!stack.isEmpty()) sb.append(stack.removeLast());
    
    while (sb.length() > 0 && sb.charAt(0) == '0') sb.deleteCharAt(0);
    return sb.length() == 0 ? "0" : sb.toString();
}
```

**思路**：单调递增栈，优先移除高位的较大数字，最后处理前导零。

### 4. 表达式求值类

#### 224. 基本计算器

```java
public int calculate(String s) {
    Deque<Integer> stack = new ArrayDeque<>();
    int result = 0, num = 0, sign = 1;
    
    for (char c : s.toCharArray()) {
        if (Character.isDigit(c)) {
            num = num * 10 + (c - '0');
        } else if (c == '+') {
            result += sign * num;
            num = 0; sign = 1;
        } else if (c == '-') {
            result += sign * num;
            num = 0; sign = -1;
        } else if (c == '(') {
            stack.push(result);
            stack.push(sign);
            result = 0; sign = 1;
        } else if (c == ')') {
            result += sign * num;
            num = 0;
            result *= stack.pop();
            result += stack.pop();
        }
    }
    return result + sign * num;
}
```

**思路**：用栈保存括号前的结果和符号，递归处理括号内的表达式。

#### 20. 有效的括号

```java
public boolean isValid(String s) {
    Deque<Character> stack = new ArrayDeque<>();
    Map<Character, Character> map = Map.of(')', '(', '}', '{', ']', '[');
    
    for (char c : s.toCharArray()) {
        if (map.containsKey(c)) {
            if (stack.isEmpty() || stack.pop() != map.get(c)) return false;
        } else {
            stack.push(c);
        }
    }
    return stack.isEmpty();
}
```

**思路**：用栈匹配左右括号，遇到右括号时检查栈顶是否为对应左括号。

## 二、单调队列问题

### 1. 滑动窗口最值类

#### 239. 滑动窗口最大值

```java
public int[] maxSlidingWindow(int[] nums, int k) {
    Deque<Integer> deque = new ArrayDeque<>();
    int[] result = new int[nums.length - k + 1];
    
    for (int i = 0; i < nums.length; i++) {
        while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {
            deque.pollFirst();
        }
        while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]) {
            deque.pollLast();
        }
        deque.offerLast(i);
        
        if (i >= k - 1) {
            result[i - k + 1] = nums[deque.peekFirst()];
        }
    }
    return result;
}
```

**思路**：单调递减队列维护窗口内元素索引，队首始终是当前窗口最大值。

#### 918. 环形子数组的最大和

```java
public int maxSubarraySumCircular(int[] nums) {
    int maxKadane = kadane(nums);
    int totalSum = 0;
    for (int i = 0; i < nums.length; i++) {
        totalSum += nums[i];
        nums[i] = -nums[i];
    }
    int maxCircular = totalSum + kadane(nums);
    return maxCircular == 0 ? maxKadane : Math.max(maxKadane, maxCircular);
}

private int kadane(int[] nums) {
    int maxSoFar = nums[0], maxEndingHere = nums[0];
    for (int i = 1; i < nums.length; i++) {
        maxEndingHere = Math.max(nums[i], maxEndingHere + nums[i]);
        maxSoFar = Math.max(maxSoFar, maxEndingHere);
    }
    return maxSoFar;
}
```

**思路**：分别计算普通子数组最大和与环形子数组最大和（总和减去子数组最小和）。

### 2. 约束优化类

#### 862. 和至少为K的最短子数组

```java
public int shortestSubarray(int[] nums, int k) {
    int n = nums.length;
    long[] prefixSum = new long[n + 1];
    for (int i = 0; i < n; i++) {
        prefixSum[i + 1] = prefixSum[i] + nums[i];
    }
    
    Deque<Integer> deque = new ArrayDeque<>();
    int result = Integer.MAX_VALUE;
    
    for (int i = 0; i <= n; i++) {
        while (!deque.isEmpty() && prefixSum[i] - prefixSum[deque.peekFirst()] >= k) {
            result = Math.min(result, i - deque.pollFirst());
        }
        while (!deque.isEmpty() && prefixSum[i] <= prefixSum[deque.peekLast()]) {
            deque.pollLast();
        }
        deque.offerLast(i);
    }
    return result == Integer.MAX_VALUE ? -1 : result;
}
```

**思路**：单调递增队列维护前缀和索引，贪心地找到满足条件的最短子数组。

## 三、解题模板总结

### 单调栈模板

```java
Deque<Integer> stack = new ArrayDeque<>();
for (int i = 0; i < nums.length; i++) {
    while (!stack.isEmpty() && condition) {
        // 处理栈顶元素
        stack.pop();
    }
    // 处理当前元素
    stack.push(i);
}
```

### 单调队列模板

```java
Deque<Integer> deque = new ArrayDeque<>();
for (int i = 0; i < nums.length; i++) {
    // 移除过期元素
    while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {
        deque.pollFirst();
    }
    // 维护单调性
    while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]) {
        deque.pollLast();
    }
    deque.offerLast(i);
    // 获取结果
    if (i >= k - 1) result[i - k + 1] = nums[deque.peekFirst()];
}
```

**核心思想**：单调栈/队列通过维护单调性来优化暴力解法的时间复杂度，关键在于确定何时入栈/队、何时出栈/队以及如何利用单调性质。

找到具有 4 个许可证类型的类似代码
