基于面试中常见的多线程问题，我将其分类总结如下：

## 1. 顺序执行类问题

### 1.1 三线程顺序打印ABC

**思路**：使用volatile变量或Condition来控制线程执行顺序

```java
// 方法1：使用volatile
class PrintABC {
    private volatile int state = 0;
    
    public void printA() {
        while (state % 3 != 0) Thread.yield();
        System.out.print("A");
        state++;
    }
    
    public void printB() {
        while (state % 3 != 1) Thread.yield();
        System.out.print("B");
        state++;
    }
    
    public void printC() {
        while (state % 3 != 2) Thread.yield();
        System.out.print("C");
        state++;
    }
}

// 方法2：使用Condition
class PrintABCCondition {
    private final Lock lock = new ReentrantLock();
    private final Condition conditionA = lock.newCondition();
    private final Condition conditionB = lock.newCondition();
    private final Condition conditionC = lock.newCondition();
    private int state = 0;
    
    public void printA() throws InterruptedException {
        lock.lock();
        try {
            while (state % 3 != 0) conditionA.await();
            System.out.print("A");
            state++;
            conditionB.signal();
        } finally {
            lock.unlock();
        }
    }
    
    public void printB() throws InterruptedException {
        lock.lock();
        try {
            while (state % 3 != 1) conditionB.await();
            System.out.print("B");
            state++;
            conditionC.signal();
        } finally {
            lock.unlock();
        }
    }
    
    public void printC() throws InterruptedException {
        lock.lock();
        try {
            while (state % 3 != 2) conditionC.await();
            System.out.print("C");
            state++;
            conditionA.signal();
        } finally {
            lock.unlock();
        }
    }
}
```

### 1.2 两线程交替打印奇偶数

**思路**：使用同步机制让两个线程协调工作，一个打印奇数一个打印偶数

```java
class OddEvenPrinter {
    private volatile int count = 1;
    private final Object lock = new Object();
    
    public void printOdd() {
        synchronized (lock) {
            while (count <= 100) {
                if (count % 2 == 1) {
                    System.out.println("奇数线程: " + count++);
                    lock.notify();
                } else {
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }
            }
        }
    }
    
    public void printEven() {
        synchronized (lock) {
            while (count <= 100) {
                if (count % 2 == 0) {
                    System.out.println("偶数线程: " + count++);
                    lock.notify();
                } else {
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }
            }
        }
    }
}
```

## 2. 生产者消费者问题

### 2.1 经典生产者消费者

**思路**：使用阻塞队列或wait/notify机制实现缓冲区管理

```java
// 使用BlockingQueue
class ProducerConsumer {
    private final BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(10);
    
    class Producer implements Runnable {
        public void run() {
            try {
                for (int i = 0; i < 100; i++) {
                    queue.put(i);
                    System.out.println("生产: " + i);
                    Thread.sleep(100);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
    
    class Consumer implements Runnable {
        public void run() {
            try {
                while (true) {
                    Integer item = queue.take();
                    System.out.println("消费: " + item);
                    Thread.sleep(150);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
}

// 使用wait/notify
class ProducerConsumerWaitNotify {
    private final Queue<Integer> queue = new LinkedList<>();
    private final int maxSize = 10;
    private final Object lock = new Object();
    
    public void produce() throws InterruptedException {
        int value = 0;
        while (true) {
            synchronized (lock) {
                while (queue.size() == maxSize) {
                    lock.wait();
                }
                queue.offer(++value);
                System.out.println("生产: " + value);
                lock.notifyAll();
            }
            Thread.sleep(100);
        }
    }
    
    public void consume() throws InterruptedException {
        while (true) {
            synchronized (lock) {
                while (queue.isEmpty()) {
                    lock.wait();
                }
                int value = queue.poll();
                System.out.println("消费: " + value);
                lock.notifyAll();
            }
            Thread.sleep(150);
        }
    }
}
```

## 3. 哲学家就餐问题

**思路**：避免死锁的经典问题，可用资源排序、超时、或信号量解决

```java
class DiningPhilosophers {
    private final Semaphore[] forks;
    private final int philosopherCount;
    
    public DiningPhilosophers(int count) {
        this.philosopherCount = count;
        this.forks = new Semaphore[count];
        for (int i = 0; i < count; i++) {
            forks[i] = new Semaphore(1);
        }
    }
    
    public void eat(int philosopherId) throws InterruptedException {
        int leftFork = philosopherId;
        int rightFork = (philosopherId + 1) % philosopherCount;
        
        // 资源排序避免死锁
        if (leftFork < rightFork) {
            forks[leftFork].acquire();
            forks[rightFork].acquire();
        } else {
            forks[rightFork].acquire();
            forks[leftFork].acquire();
        }
        
        try {
            System.out.println("哲学家 " + philosopherId + " 正在用餐");
            Thread.sleep(1000);
        } finally {
            forks[leftFork].release();
            forks[rightFork].release();
            System.out.println("哲学家 " + philosopherId + " 用餐完毕");
        }
    }
}
```

## 4. 读者写者问题

**思路**：允许多个读者同时访问，但写者需要独占访问

```java
class ReaderWriter {
    private final ReadWriteLock lock = new ReentrantReadWriteLock();
    private final Lock readLock = lock.readLock();
    private final Lock writeLock = lock.writeLock();
    private String data = "初始数据";
    
    public String read() {
        readLock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + " 正在读取: " + data);
            Thread.sleep(1000);
            return data;
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return null;
        } finally {
            readLock.unlock();
        }
    }
    
    public void write(String newData) {
        writeLock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + " 正在写入: " + newData);
            this.data = newData;
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            writeLock.unlock();
        }
    }
}
```

## 5. 线程池相关问题

### 5.1 手动实现简单线程池

**思路**：维护工作线程队列和任务队列，工作线程不断从任务队列取任务执行

```java
class SimpleThreadPool {
    private final BlockingQueue<Runnable> taskQueue;
    private final List<WorkerThread> workers;
    private volatile boolean isShutdown = false;
    
    public SimpleThreadPool(int poolSize) {
        taskQueue = new LinkedBlockingQueue<>();
        workers = new ArrayList<>(poolSize);
        
        for (int i = 0; i < poolSize; i++) {
            WorkerThread worker = new WorkerThread();
            workers.add(worker);
            worker.start();
        }
    }
    
    public void submit(Runnable task) {
        if (!isShutdown) {
            taskQueue.offer(task);
        }
    }
    
    public void shutdown() {
        isShutdown = true;
        for (WorkerThread worker : workers) {
            worker.interrupt();
        }
    }
    
    private class WorkerThread extends Thread {
        public void run() {
            while (!isShutdown) {
                try {
                    Runnable task = taskQueue.take();
                    task.run();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        }
    }
}
```

## 6. 并发工具类应用

### 6.1 CountDownLatch实现等待所有子任务完成

**思路**：主线程等待多个子线程全部完成后再继续执行

```java
class CountDownLatchExample {
    public void waitForAllTasks() throws InterruptedException {
        int taskCount = 5;
        CountDownLatch latch = new CountDownLatch(taskCount);
        
        for (int i = 0; i < taskCount; i++) {
            final int taskId = i;
            new Thread(() -> {
                try {
                    System.out.println("任务 " + taskId + " 开始执行");
                    Thread.sleep((taskId + 1) * 1000);
                    System.out.println("任务 " + taskId + " 执行完成");
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } finally {
                    latch.countDown();
                }
            }).start();
        }
        
        latch.await();
        System.out.println("所有任务执行完成");
    }
}
```

### 6.2 CyclicBarrier实现多线程同步点

**思路**：让多个线程在某个同步点相互等待，全部到达后一起继续执行

```java
class CyclicBarrierExample {
    public void syncThreads() {
        int threadCount = 3;
        CyclicBarrier barrier = new CyclicBarrier(threadCount, () -> {
            System.out.println("所有线程都到达屏障点，继续执行");
        });
        
        for (int i = 0; i < threadCount; i++) {
            final int threadId = i;
            new Thread(() -> {
                try {
                    System.out.println("线程 " + threadId + " 到达屏障点");
                    barrier.await();
                    System.out.println("线程 " + threadId + " 继续执行");
                } catch (InterruptedException | BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}
```

### 6.3 Semaphore实现资源池

**思路**：控制同时访问某个资源的线程数量

```java
class SemaphoreResourcePool {
    private final Semaphore semaphore;
    private final boolean[] resources;
    private final boolean[] used;
    
    public SemaphoreResourcePool(int size) {
        this.semaphore = new Semaphore(size, true);
        this.resources = new boolean[size];
        this.used = new boolean[size];
    }
    
    public int acquire() throws InterruptedException {
        semaphore.acquire();
        return getResource();
    }
    
    public void release(int resourceId) {
        if (makeResourceAvailable(resourceId)) {
            semaphore.release();
        }
    }
    
    private synchronized int getResource() {
        for (int i = 0; i < used.length; i++) {
            if (!used[i]) {
                used[i] = true;
                return i;
            }
        }
        return -1;
    }
    
    private synchronized boolean makeResourceAvailable(int resourceId) {
        if (used[resourceId]) {
            used[resourceId] = false;
            return true;
        }
        return false;
    }
}
```

## 7. 死锁问题

### 7.1 死锁检测和避免

**思路**：通过资源排序、超时机制、银行家算法等避免死锁

```java
class DeadlockAvoidance {
    private final Object lock1 = new Object();
    private final Object lock2 = new Object();
    
    // 避免死锁的方法：资源排序
    public void method1() {
        synchronized (lock1) {
            System.out.println("Method1: 获得lock1");
            synchronized (lock2) {
                System.out.println("Method1: 获得lock2");
            }
        }
    }
    
    public void method2() {
        synchronized (lock1) { // 与method1相同的顺序
            System.out.println("Method2: 获得lock1");
            synchronized (lock2) {
                System.out.println("Method2: 获得lock2");
            }
        }
    }
    
    // 使用tryLock避免死锁
    private final ReentrantLock lockA = new ReentrantLock();
    private final ReentrantLock lockB = new ReentrantLock();
    
    public void methodWithTimeout() throws InterruptedException {
        if (lockA.tryLock(1000, TimeUnit.MILLISECONDS)) {
            try {
                if (lockB.tryLock(1000, TimeUnit.MILLISECONDS)) {
                    try {
                        System.out.println("成功获得两个锁");
                    } finally {
                        lockB.unlock();
                    }
                }
            } finally {
                lockA.unlock();
            }
        }
    }
}
```

## 8. 特殊场景问题

### 8.1 限流器实现

**思路**：使用令牌桶或滑动窗口算法控制访问频率

```java
class RateLimiter {
    private final int capacity;
    private final int refillRate;
    private int tokens;
    private long lastRefillTime;
    private final Object lock = new Object();
    
    public RateLimiter(int capacity, int refillRate) {
        this.capacity = capacity;
        this.refillRate = refillRate;
        this.tokens = capacity;
        this.lastRefillTime = System.currentTimeMillis();
    }
    
    public boolean tryAcquire() {
        synchronized (lock) {
            refillTokens();
            if (tokens > 0) {
                tokens--;
                return true;
            }
            return false;
        }
    }
    
    private void refillTokens() {
        long now = System.currentTimeMillis();
        long timePassed = now - lastRefillTime;
        int tokensToAdd = (int) (timePassed / 1000 * refillRate);
        
        if (tokensToAdd > 0) {
            tokens = Math.min(capacity, tokens + tokensToAdd);
            lastRefillTime = now;
        }
    }
}
```

### 8.2 缓存淘汰策略（LRU）

**思路**：使用双向链表+HashMap实现线程安全的LRU缓存

```java
class LRUCache<K, V> {
    private final int capacity;
    private final Map<K, Node<K, V>> cache;
    private final Node<K, V> head;
    private final Node<K, V> tail;
    private final ReadWriteLock lock = new ReentrantReadWriteLock();
    
    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.cache = new HashMap<>();
        this.head = new Node<>(null, null);
        this.tail = new Node<>(null, null);
        head.next = tail;
        tail.prev = head;
    }
    
    public V get(K key) {
        lock.readLock().lock();
        try {
            Node<K, V> node = cache.get(key);
            if (node != null) {
                moveToHead(node);
                return node.value;
            }
            return null;
        } finally {
            lock.readLock().unlock();
        }
    }
    
    public void put(K key, V value) {
        lock.writeLock().lock();
        try {
            Node<K, V> node = cache.get(key);
            if (node != null) {
                node.value = value;
                moveToHead(node);
            } else {
                Node<K, V> newNode = new Node<>(key, value);
                cache.put(key, newNode);
                addToHead(newNode);
                
                if (cache.size() > capacity) {
                    Node<K, V> tail = removeTail();
                    cache.remove(tail.key);
                }
            }
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    private void addToHead(Node<K, V> node) {
        node.prev = head;
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
    }
    
    private void removeNode(Node<K, V> node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
    
    private void moveToHead(Node<K, V> node) {
        removeNode(node);
        addToHead(node);
    }
    
    private Node<K, V> removeTail() {
        Node<K, V> lastNode = tail.prev;
        removeNode(lastNode);
        return lastNode;
    }
    
    static class Node<K, V> {
        K key;
        V value;
        Node<K, V> prev;
        Node<K, V> next;
        
        Node(K key, V value) {
            this.key = key;
            this.value = value;
        }
    }
}
```

这些问题涵盖了面试中最常见的多线程场景，每种解法都有其特定的应用场景和优缺点。掌握这些模式可以帮助解决大部分多线程相关的面试题。

找到具有 1 个许可证类型的类似代码
