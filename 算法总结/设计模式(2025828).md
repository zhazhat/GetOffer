根据面试中常见的设计模式问题，我将其分类总结如下：

## 1. 创建型模式

### 单例模式 (Singleton)

**问题**：如何确保一个类只有一个实例？

**思路**：私有构造函数 + 静态实例变量 + 公共静态访问方法

```java
// 双重检查锁定
public class Singleton {
    private volatile static Singleton instance;
    
    private Singleton() {}
    
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

### 工厂模式 (Factory)

**问题**：如何创建对象而不指定具体类？

**思路**：定义创建接口，让子类决定实例化哪个类

```java
interface Product {
    void use();
}

class ConcreteProductA implements Product {
    public void use() { System.out.println("Using Product A"); }
}

abstract class Factory {
    public abstract Product createProduct();
}

class ConcreteFactoryA extends Factory {
    public Product createProduct() {
        return new ConcreteProductA();
    }
}
```

### 建造者模式 (Builder)

**问题**：如何构建复杂对象？

**思路**：分步骤构建复杂对象，同样的构建过程可以创建不同的表示

```java
public class Computer {
    private String cpu;
    private String memory;
    private String storage;
    
    private Computer(Builder builder) {
        this.cpu = builder.cpu;
        this.memory = builder.memory;
        this.storage = builder.storage;
    }
    
    public static class Builder {
        private String cpu;
        private String memory;
        private String storage;
        
        public Builder setCpu(String cpu) {
            this.cpu = cpu;
            return this;
        }
        
        public Builder setMemory(String memory) {
            this.memory = memory;
            return this;
        }
        
        public Computer build() {
            return new Computer(this);
        }
    }
}
```

## 2. 结构型模式

### 适配器模式 (Adapter)

**问题**：如何让不兼容的接口协同工作？

**思路**：创建适配器类实现目标接口，内部持有被适配对象的引用

```java
interface Target {
    void request();
}

class Adaptee {
    public void specificRequest() {
        System.out.println("Specific request");
    }
}

class Adapter implements Target {
    private Adaptee adaptee;
    
    public Adapter(Adaptee adaptee) {
        this.adaptee = adaptee;
    }
    
    public void request() {
        adaptee.specificRequest();
    }
}
```

### 装饰器模式 (Decorator)

**问题**：如何动态地给对象添加功能？

**思路**：装饰器与被装饰对象实现同一接口，装饰器持有被装饰对象的引用

```java
interface Component {
    void operation();
}

class ConcreteComponent implements Component {
    public void operation() {
        System.out.println("Base operation");
    }
}

abstract class Decorator implements Component {
    protected Component component;
    
    public Decorator(Component component) {
        this.component = component;
    }
    
    public void operation() {
        component.operation();
    }
}

class ConcreteDecorator extends Decorator {
    public ConcreteDecorator(Component component) {
        super(component);
    }
    
    public void operation() {
        super.operation();
        addedBehavior();
    }
    
    private void addedBehavior() {
        System.out.println("Added behavior");
    }
}
```

### 代理模式 (Proxy)

**问题**：如何控制对对象的访问？

**思路**：代理类与目标类实现同一接口，代理类持有目标对象引用并控制访问

```java
interface Subject {
    void request();
}

class RealSubject implements Subject {
    public void request() {
        System.out.println("Real subject request");
    }
}

class Proxy implements Subject {
    private RealSubject realSubject;
    
    public void request() {
        if (realSubject == null) {
            realSubject = new RealSubject();
        }
        preRequest();
        realSubject.request();
        postRequest();
    }
    
    private void preRequest() {
        System.out.println("Pre-processing");
    }
    
    private void postRequest() {
        System.out.println("Post-processing");
    }
}
```

## 3. 行为型模式

### 观察者模式 (Observer)

**问题**：如何在对象状态改变时通知多个依赖对象？

**思路**：主题维护观察者列表，状态改变时遍历通知所有观察者

```java
interface Observer {
    void update(String message);
}

class Subject {
    private List<Observer> observers = new ArrayList<>();
    
    public void addObserver(Observer observer) {
        observers.add(observer);
    }
    
    public void removeObserver(Observer observer) {
        observers.remove(observer);
    }
    
    public void notifyObservers(String message) {
        for (Observer observer : observers) {
            observer.update(message);
        }
    }
}

class ConcreteObserver implements Observer {
    private String name;
    
    public ConcreteObserver(String name) {
        this.name = name;
    }
    
    public void update(String message) {
        System.out.println(name + " received: " + message);
    }
}
```

### 策略模式 (Strategy)

**问题**：如何在运行时选择算法？

**思路**：定义算法接口，封装具体算法，使算法可以互相替换

```java
interface Strategy {
    int execute(int a, int b);
}

class AddStrategy implements Strategy {
    public int execute(int a, int b) {
        return a + b;
    }
}

class SubtractStrategy implements Strategy {
    public int execute(int a, int b) {
        return a - b;
    }
}

class Context {
    private Strategy strategy;
    
    public Context(Strategy strategy) {
        this.strategy = strategy;
    }
    
    public void setStrategy(Strategy strategy) {
        this.strategy = strategy;
    }
    
    public int executeStrategy(int a, int b) {
        return strategy.execute(a, b);
    }
}
```

### 命令模式 (Command)

**问题**：如何将请求封装为对象？

**思路**：将请求封装成命令对象，包含执行所需的所有信息

```java
interface Command {
    void execute();
}

class Receiver {
    public void action() {
        System.out.println("Receiver action");
    }
}

class ConcreteCommand implements Command {
    private Receiver receiver;
    
    public ConcreteCommand(Receiver receiver) {
        this.receiver = receiver;
    }
    
    public void execute() {
        receiver.action();
    }
}

class Invoker {
    private Command command;
    
    public void setCommand(Command command) {
        this.command = command;
    }
    
    public void executeCommand() {
        command.execute();
    }
}
```

### 状态模式 (State)

**问题**：如何让对象在内部状态改变时改变行为？

**思路**：将状态封装成独立的类，每个状态类处理特定状态下的行为

```java
interface State {
    void handle(Context context);
}

class ConcreteStateA implements State {
    public void handle(Context context) {
        System.out.println("State A handling");
        context.setState(new ConcreteStateB());
    }
}

class ConcreteStateB implements State {
    public void handle(Context context) {
        System.out.println("State B handling");
        context.setState(new ConcreteStateA());
    }
}

class Context {
    private State state;
    
    public Context() {
        state = new ConcreteStateA();
    }
    
    public void setState(State state) {
        this.state = state;
    }
    
    public void request() {
        state.handle(this);
    }
}
```

### 模板方法模式 (Template Method)

**问题**：如何定义算法骨架而让子类实现具体步骤？

**思路**：抽象类定义算法框架，具体步骤延迟到子类实现

```java
abstract class AbstractClass {
    public final void templateMethod() {
        step1();
        step2();
        step3();
    }
    
    protected abstract void step1();
    protected abstract void step2();
    
    protected void step3() {
        System.out.println("Default step 3");
    }
}

class ConcreteClass extends AbstractClass {
    protected void step1() {
        System.out.println("Concrete step 1");
    }
    
    protected void step2() {
        System.out.println("Concrete step 2");
    }
}
```

### 责任链模式 (Chain of Responsibility)

**问题**：如何让多个对象都有机会处理请求？

**思路**：将处理者连成链，沿链传递请求直到有对象处理它

```java
abstract class Handler {
    protected Handler nextHandler;
    
    public void setNext(Handler handler) {
        this.nextHandler = handler;
    }
    
    public abstract void handleRequest(int request);
}

class ConcreteHandlerA extends Handler {
    public void handleRequest(int request) {
        if (request < 10) {
            System.out.println("Handler A processed request: " + request);
        } else if (nextHandler != null) {
            nextHandler.handleRequest(request);
        }
    }
}

class ConcreteHandlerB extends Handler {
    public void handleRequest(int request) {
        if (request >= 10) {
            System.out.println("Handler B processed request: " + request);
        } else if (nextHandler != null) {
            nextHandler.handleRequest(request);
        }
    }
}
```

## 4. 面试高频组合问题

### MVC模式实现

**思路**：Model处理数据，View负责显示，Controller协调两者

### 线程安全的单例模式

**思路**：使用volatile + 双重检查锁定或枚举实现

### Spring中的设计模式应用

**思路**：IoC容器(工厂模式)、AOP(代理模式)、事件机制(观察者模式)

这些模式在实际面试中经常被问到，掌握其核心思想和Java实现方式是关键。

找到具有 2 个许可证类型的类似代码
