根据面试中常见的设计问题，我将按照数据结构、并发编程、系统设计等维度进行分类总结：

## 1. 缓存设计类

### 1.1 LRU Cache

**思路：** 使用HashMap + 双向链表，HashMap存储key-node映射，双向链表维护访问顺序。

```java
class LRUCache {
    class DListNode {
        int key, value;
        DListNode prev, next;
        
        DListNode() {}
        DListNode(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }
    
    private Map<Integer, DListNode> cache = new HashMap<>();
    private int size;
    private int capacity;
    private DListNode head, tail;
    
    public LRUCache(int capacity) {
        this.size = 0;
        this.capacity = capacity;
        head = new DListNode();
        tail = new DListNode();
        head.next = tail;
        tail.prev = head;
    }
    
    public int get(int key) {
        DListNode node = cache.get(key);
        if (node == null) return -1;
        
        moveToHead(node);
        return node.value;
    }
    
    public void put(int key, int value) {
        DListNode node = cache.get(key);
        
        if (node == null) {
            DListNode newNode = new DListNode(key, value);
            cache.put(key, newNode);
            addToHead(newNode);
            ++size;
            
            if (size > capacity) {
                DListNode tail = removeTail();
                cache.remove(tail.key);
                --size;
            }
        } else {
            node.value = value;
            moveToHead(node);
        }
    }
    
    private void addToHead(DListNode node) {
        node.prev = head;
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
    }
    
    private void removeNode(DListNode node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
    
    private void moveToHead(DListNode node) {
        removeNode(node);
        addToHead(node);
    }
    
    private DListNode removeTail() {
        DListNode lastNode = tail.prev;
        removeNode(lastNode);
        return lastNode;
    }
}
```

### 1.2 带时间戳的LRU Cache

**思路：** 在LRU基础上增加过期时间检查，get时判断是否过期并清理过期数据。

```java
class TimestampLRUCache {
    class Node {
        int key, value;
        long timestamp;
        Node prev, next;
        
        Node(int key, int value, long timestamp) {
            this.key = key;
            this.value = value;
            this.timestamp = timestamp;
        }
    }
    
    private Map<Integer, Node> cache = new HashMap<>();
    private Node head, tail;
    private int capacity;
    private long ttl; // 过期时间（毫秒）
    
    public TimestampLRUCache(int capacity, long ttl) {
        this.capacity = capacity;
        this.ttl = ttl;
        head = new Node(0, 0, 0);
        tail = new Node(0, 0, 0);
        head.next = tail;
        tail.prev = head;
    }
    
    public int get(int key) {
        Node node = cache.get(key);
        if (node == null) return -1;
        
        // 检查是否过期
        if (System.currentTimeMillis() - node.timestamp > ttl) {
            removeNode(node);
            cache.remove(key);
            return -1;
        }
        
        moveToHead(node);
        return node.value;
    }
    
    public void put(int key, int value) {
        Node node = cache.get(key);
        long currentTime = System.currentTimeMillis();
        
        if (node == null) {
            Node newNode = new Node(key, value, currentTime);
            cache.put(key, newNode);
            addToHead(newNode);
            
            if (cache.size() > capacity) {
                Node tail = removeTail();
                cache.remove(tail.key);
            }
        } else {
            node.value = value;
            node.timestamp = currentTime;
            moveToHead(node);
        }
    }
    
    private void addToHead(Node node) {
        node.prev = head;
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
    }
    
    private void removeNode(Node node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
    
    private void moveToHead(Node node) {
        removeNode(node);
        addToHead(node);
    }
    
    private Node removeTail() {
        Node lastNode = tail.prev;
        removeNode(lastNode);
        return lastNode;
    }
}
```

### 1.3 LFU Cache

**思路：** 使用频次计数器+多个频次对应的双向链表，维护最小频次指针。

```java
class LFUCache {
    class Node {
        int key, value, freq;
        Node prev, next;
        
        Node(int key, int value) {
            this.key = key;
            this.value = value;
            this.freq = 1;
        }
    }
    
    class DoublyLinkedList {
        Node head, tail;
        
        DoublyLinkedList() {
            head = new Node(0, 0);
            tail = new Node(0, 0);
            head.next = tail;
            tail.prev = head;
        }
        
        void addToHead(Node node) {
            node.prev = head;
            node.next = head.next;
            head.next.prev = node;
            head.next = node;
        }
        
        void removeNode(Node node) {
            node.prev.next = node.next;
            node.next.prev = node.prev;
        }
        
        Node removeTail() {
            Node lastNode = tail.prev;
            removeNode(lastNode);
            return lastNode;
        }
        
        boolean isEmpty() {
            return head.next == tail;
        }
    }
    
    private int capacity, minFreq;
    private Map<Integer, Node> nodeMap;
    private Map<Integer, DoublyLinkedList> freqMap;
    
    public LFUCache(int capacity) {
        this.capacity = capacity;
        this.minFreq = 0;
        this.nodeMap = new HashMap<>();
        this.freqMap = new HashMap<>();
    }
    
    public int get(int key) {
        Node node = nodeMap.get(key);
        if (node == null) return -1;
        
        updateFreq(node);
        return node.value;
    }
    
    public void put(int key, int value) {
        if (capacity <= 0) return;
        
        Node node = nodeMap.get(key);
        if (node != null) {
            node.value = value;
            updateFreq(node);
        } else {
            if (nodeMap.size() >= capacity) {
                DoublyLinkedList minFreqList = freqMap.get(minFreq);
                Node nodeToRemove = minFreqList.removeTail();
                nodeMap.remove(nodeToRemove.key);
            }
            
            Node newNode = new Node(key, value);
            nodeMap.put(key, newNode);
            freqMap.computeIfAbsent(1, k -> new DoublyLinkedList()).addToHead(newNode);
            minFreq = 1;
        }
    }
    
    private void updateFreq(Node node) {
        int freq = node.freq;
        DoublyLinkedList oldList = freqMap.get(freq);
        oldList.removeNode(node);
        
        if (freq == minFreq && oldList.isEmpty()) {
            minFreq++;
        }
        
        node.freq++;
        freqMap.computeIfAbsent(freq + 1, k -> new DoublyLinkedList()).addToHead(node);
    }
}
```

## 2. 并发编程类

### 2.1 线程池

**思路：** 核心线程池+任务队列+线程工厂+拒绝策略，通过工作线程循环从队列取任务执行。

```java
public class SimpleThreadPool {
    private final int corePoolSize;
    private final int maximumPoolSize;
    private final BlockingQueue<Runnable> workQueue;
    private final Set<Worker> workers = new HashSet<>();
    private final ReentrantLock mainLock = new ReentrantLock();
    private volatile boolean shutdown = false;
    
    public SimpleThreadPool(int corePoolSize, int maximumPoolSize, 
                           BlockingQueue<Runnable> workQueue) {
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
    }
    
    public void execute(Runnable command) {
        if (command == null) throw new NullPointerException();
        
        int c = workers.size();
        if (c < corePoolSize) {
            if (addWorker(command, true)) return;
        }
        
        if (!workQueue.offer(command)) {
            if (!addWorker(command, false)) {
                reject(command);
            }
        }
    }
    
    private boolean addWorker(Runnable firstTask, boolean core) {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            if (shutdown) return false;
            
            int wc = workers.size();
            if (wc >= (core ? corePoolSize : maximumPoolSize)) {
                return false;
            }
            
            Worker w = new Worker(firstTask);
            workers.add(w);
            w.thread.start();
            return true;
        } finally {
            mainLock.unlock();
        }
    }
    
    private void reject(Runnable command) {
        throw new RuntimeException("Task " + command.toString() + " rejected");
    }
    
    public void shutdown() {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            shutdown = true;
            for (Worker w : workers) {
                w.thread.interrupt();
            }
        } finally {
            mainLock.unlock();
        }
    }
    
    private final class Worker implements Runnable {
        final Thread thread;
        Runnable firstTask;
        
        Worker(Runnable firstTask) {
            this.firstTask = firstTask;
            this.thread = new Thread(this);
        }
        
        public void run() {
            runWorker(this);
        }
    }
    
    private void runWorker(Worker w) {
        Runnable task = w.firstTask;
        w.firstTask = null;
        
        while (task != null || (task = getTask()) != null) {
            try {
                task.run();
            } finally {
                task = null;
            }
        }
        
        workerDone(w);
    }
    
    private Runnable getTask() {
        if (shutdown) return null;
        
        try {
            return workQueue.take();
        } catch (InterruptedException e) {
            return null;
        }
    }
    
    private void workerDone(Worker w) {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            workers.remove(w);
        } finally {
            mainLock.unlock();
        }
    }
}
```

### 2.2 生产者消费者模式

**思路：** 使用阻塞队列实现线程间通信，生产者放入数据，消费者取出数据。

```java
public class ProducerConsumer {
    private final BlockingQueue<Integer> queue;
    private final int capacity;
    
    public ProducerConsumer(int capacity) {
        this.capacity = capacity;
        this.queue = new ArrayBlockingQueue<>(capacity);
    }
    
    class Producer implements Runnable {
        public void run() {
            try {
                int value = 0;
                while (!Thread.currentThread().isInterrupted()) {
                    queue.put(value);
                    System.out.println("Produced " + value);
                    value++;
                    Thread.sleep(1000);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
    
    class Consumer implements Runnable {
        public void run() {
            try {
                while (!Thread.currentThread().isInterrupted()) {
                    int value = queue.take();
                    System.out.println("Consumed " + value);
                    Thread.sleep(1000);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
}
```

### 2.3 读写锁

**思路：** 读锁可以并发，写锁独占，使用状态变量记录读写锁状态。

```java
public class SimpleReadWriteLock {
    private int readers = 0;
    private int writers = 0;
    private int writeRequests = 0;
    
    public synchronized void lockRead() throws InterruptedException {
        while (writers > 0 || writeRequests > 0) {
            wait();
        }
        readers++;
    }
    
    public synchronized void unlockRead() {
        readers--;
        notifyAll();
    }
    
    public synchronized void lockWrite() throws InterruptedException {
        writeRequests++;
        while (readers > 0 || writers > 0) {
            wait();
        }
        writeRequests--;
        writers++;
    }
    
    public synchronized void unlockWrite() {
        writers--;
        notifyAll();
    }
}
```

## 3. 系统设计类

### 3.1 单例模式（线程安全）

**思路：** 双重检查锁定确保线程安全和性能。

```java
public class Singleton {
    private static volatile Singleton instance;
    
    private Singleton() {}
    
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

### 3.2 对象池

**思路：** 预创建对象放入池中，使用时从池中取出，用完后归还。

```java
public class ObjectPool<T> {
    private final Queue<T> pool = new ConcurrentLinkedQueue<>();
    private final Supplier<T> objectFactory;
    private final int maxSize;
    private final AtomicInteger size = new AtomicInteger(0);
    
    public ObjectPool(Supplier<T> objectFactory, int maxSize) {
        this.objectFactory = objectFactory;
        this.maxSize = maxSize;
    }
    
    public T borrowObject() {
        T object = pool.poll();
        if (object == null) {
            object = objectFactory.get();
        } else {
            size.decrementAndGet();
        }
        return object;
    }
    
    public void returnObject(T object) {
        if (object != null && size.get() < maxSize) {
            pool.offer(object);
            size.incrementAndGet();
        }
    }
}
```

### 3.3 发布订阅模式

**思路：** 维护主题到订阅者列表的映射，发布时通知所有订阅者。

```java
public class EventBus {
    private final Map<String, List<Subscriber>> subscribers = new ConcurrentHashMap<>();
    
    public void subscribe(String topic, Subscriber subscriber) {
        subscribers.computeIfAbsent(topic, k -> new CopyOnWriteArrayList<>())
                  .add(subscriber);
    }
    
    public void unsubscribe(String topic, Subscriber subscriber) {
        List<Subscriber> topicSubscribers = subscribers.get(topic);
        if (topicSubscribers != null) {
            topicSubscribers.remove(subscriber);
        }
    }
    
    public void publish(String topic, Object event) {
        List<Subscriber> topicSubscribers = subscribers.get(topic);
        if (topicSubscribers != null) {
            for (Subscriber subscriber : topicSubscribers) {
                try {
                    subscriber.onEvent(event);
                } catch (Exception e) {
                    // 处理异常
                }
            }
        }
    }
    
    public interface Subscriber {
        void onEvent(Object event);
    }
}
```

## 4. 数据结构设计类

### 4.1 跳表

**思路：** 多层链表结构，上层作为下层的快速通道，实现O(logN)的查找。

```java
public class SkipList {
    class Node {
        int val;
        Node[] next;
        
        Node(int val, int level) {
            this.val = val;
            this.next = new Node[level];
        }
    }
    
    private static final int MAX_LEVEL = 16;
    private Node head;
    private int level;
    private Random random;
    
    public SkipList() {
        head = new Node(-1, MAX_LEVEL);
        level = 1;
        random = new Random();
    }
    
    public boolean search(int target) {
        Node curr = head;
        for (int i = level - 1; i >= 0; i--) {
            while (curr.next[i] != null && curr.next[i].val < target) {
                curr = curr.next[i];
            }
        }
        curr = curr.next[0];
        return curr != null && curr.val == target;
    }
    
    public void add(int num) {
        Node[] update = new Node[MAX_LEVEL];
        Node curr = head;
        
        for (int i = level - 1; i >= 0; i--) {
            while (curr.next[i] != null && curr.next[i].val < num) {
                curr = curr.next[i];
            }
            update[i] = curr;
        }
        
        int newLevel = randomLevel();
        if (newLevel > level) {
            for (int i = level; i < newLevel; i++) {
                update[i] = head;
            }
            level = newLevel;
        }
        
        Node newNode = new Node(num, newLevel);
        for (int i = 0; i < newLevel; i++) {
            newNode.next[i] = update[i].next[i];
            update[i].next[i] = newNode;
        }
    }
    
    private int randomLevel() {
        int level = 1;
        while (random.nextDouble() < 0.5 && level < MAX_LEVEL) {
            level++;
        }
        return level;
    }
}
```

### 4.2 Trie树

**思路：** 树形结构存储字符串，每个节点代表一个字符，路径代表字符串前缀。

```java
public class Trie {
    class TrieNode {
        boolean isEnd;
        TrieNode[] children;
        
        TrieNode() {
            isEnd = false;
            children = new TrieNode[26];
        }
    }
    
    private TrieNode root;
    
    public Trie() {
        root = new TrieNode();
    }
    
    public void insert(String word) {
        TrieNode node = root;
        for (char c : word.toCharArray()) {
            int index = c - 'a';
            if (node.children[index] == null) {
                node.children[index] = new TrieNode();
            }
            node = node.children[index];
        }
        node.isEnd = true;
    }
    
    public boolean search(String word) {
        TrieNode node = searchPrefix(word);
        return node != null && node.isEnd;
    }
    
    public boolean startsWith(String prefix) {
        return searchPrefix(prefix) != null;
    }
    
    private TrieNode searchPrefix(String prefix) {
        TrieNode node = root;
        for (char c : prefix.toCharArray()) {
            int index = c - 'a';
            if (node.children[index] == null) {
                return null;
            }
            node = node.children[index];
        }
        return node;
    }
}
```

### 4.3 布隆过滤器

**思路：** 位数组+多个哈希函数，判断元素可能存在或一定不存在。

```java
public class BloomFilter {
    private BitSet bitSet;
    private int bitSetSize;
    private int expectedElements;
    private int hashFunctions;
    
    public BloomFilter(int expectedElements, double falsePositiveRate) {
        this.expectedElements = expectedElements;
        // biset大小根据预估错误率与决定
        this.bitSetSize = (int) (-expectedElements * Math.log(falsePositiveRate) / (Math.log(2) * Math.log(2)));
        this.hashFunctions = (int) (bitSetSize * Math.log(2) / expectedElements);
        this.bitSet = new BitSet(bitSetSize);
    }
    
    public void add(String element) {
        for (int i = 0; i < hashFunctions; i++) {
            int hash = hash(element, i);
            bitSet.set(Math.abs(hash % bitSetSize));
        }
    }
    
    public boolean mightContain(String element) {
        for (int i = 0; i < hashFunctions; i++) {
            int hash = hash(element, i);
            if (!bitSet.get(Math.abs(hash % bitSetSize))) {
                return false;
            }
        }
        return true;
    }
    
    private int hash(String element, int seed) {
        return element.hashCode() * seed;
    }
}
```

## 5. 限流器设计类

### 5.1 令牌桶限流器

**思路：** 固定速率产生令牌放入桶中，请求消耗令牌，桶空则拒绝请求。

```java
public class TokenBucket {
    private final long capacity;
    private final long refillRate;
    private long tokens;
    private long lastRefillTime;
    
    public TokenBucket(long capacity, long refillRate) {
        this.capacity = capacity;
        this.refillRate = refillRate;
        this.tokens = capacity;
        this.lastRefillTime = System.currentTimeMillis();
    }
    
    public synchronized boolean tryConsume(long tokensRequested) {
        refill();
        
        if (tokens >= tokensRequested) {
            tokens -= tokensRequested;
            return true;
        }
        return false;
    }
    
    private void refill() {
        long now = System.currentTimeMillis();
        long tokensToAdd = (now - lastRefillTime) * refillRate / 1000;
        tokens = Math.min(capacity, tokens + tokensToAdd);
        lastRefillTime = now;
    }
}
```

### 5.2 滑动窗口限流器

**思路：** 维护时间窗口内的请求计数，超出限制则拒绝请求。

```java
public class SlidingWindowRateLimiter {
    private final Queue<Long> requestTimes;
    private final int maxRequests;
    private final long windowSizeMs;
    
    public SlidingWindowRateLimiter(int maxRequests, long windowSizeMs) {
        this.requestTimes = new LinkedList<>();
        this.maxRequests = maxRequests;
        this.windowSizeMs = windowSizeMs;
    }
    
    public synchronized boolean tryAcquire() {
        long now = System.currentTimeMillis();
        
        // 清理过期的请求时间
        while (!requestTimes.isEmpty() && now - requestTimes.peek() > windowSizeMs) {
            requestTimes.poll();
        }
        
        if (requestTimes.size() < maxRequests) {
            requestTimes.offer(now);
            return true;
        }
        
        return false;
    }
}
```

这些设计问题涵盖了面试中最常见的场景，每个实现都考虑了线程安全、性能优化和边界条件处理。掌握这些模式和思路，可以帮助应对大部分系统设计面试题。
