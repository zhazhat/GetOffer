根据附件内容，我来分类总结力扣中常见的二叉树问题及解法：

## 1. 二叉树遍历

### 前序遍历（144）

```java
// 递归
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    preorder(root, result);
    return result;
}
private void preorder(TreeNode node, List<Integer> result) {
    if (node == null) return;
    result.add(node.val);
    preorder(node.left, result);
    preorder(node.right, result);
}

// 迭代
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    Stack<TreeNode> stack = new Stack<>();
    if (root != null) stack.push(root);
    
    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        result.add(node.val);
        if (node.right != null) stack.push(node.right);
        if (node.left != null) stack.push(node.left);
    }
    return result;
}
```

**思路：** 根-左-右的顺序访问，迭代时用栈模拟递归过程。

### 中序遍历（94）

```java
// 递归
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    inorder(root, result);
    return result;
}
private void inorder(TreeNode node, List<Integer> result) {
    if (node == null) return;
    inorder(node.left, result);
    result.add(node.val);
    inorder(node.right, result);
}

// 迭代
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    Stack<TreeNode> stack = new Stack<>();
    TreeNode curr = root;
    
    while (curr != null || !stack.isEmpty()) {
        while (curr != null) {
            stack.push(curr);
            curr = curr.left;
        }
        curr = stack.pop();
        result.add(curr.val);
        curr = curr.right;
    }
    return result;
}
```

**思路：** 左-根-右的顺序访问，迭代时先走到最左边再回溯。

### 后序遍历（145）

```java
// 递归
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    postorder(root, result);
    return result;
}
private void postorder(TreeNode node, List<Integer> result) {
    if (node == null) return;
    postorder(node.left, result);
    postorder(node.right, result);
    result.add(node.val);
}

// 迭代
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    Stack<TreeNode> stack = new Stack<>();
    TreeNode lastVisited = null;
    TreeNode curr = root;
    
    while (curr != null || !stack.isEmpty()) {
        if (curr != null) {
            stack.push(curr);
            curr = curr.left;
        } else {
            TreeNode peekNode = stack.peek();
            if (peekNode.right != null && lastVisited != peekNode.right) {
                curr = peekNode.right;
            } else {
                result.add(peekNode.val);
                lastVisited = stack.pop();
            }
        }
    }
    return result;
}
```

**思路：** 左-右-根的顺序访问，需要记录上次访问的节点避免重复访问右子树。

### 层序遍历（102）

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) return result;
    
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    
    while (!queue.isEmpty()) {
        int levelSize = queue.size();
        List<Integer> currentLevel = new ArrayList<>();
        
        for (int i = 0; i < levelSize; i++) {
            TreeNode node = queue.poll();
            currentLevel.add(node.val);
            
            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
        }
        result.add(currentLevel);
    }
    return result;
}
```

**思路：** 使用队列实现BFS，记录每层节点数量来分层。

## 2. 二叉树构造

### 从前序和中序构造二叉树（105）

```java
public TreeNode buildTree(int[] preorder, int[] inorder) {
    Map<Integer, Integer> inorderMap = new HashMap<>();
    for (int i = 0; i < inorder.length; i++) {
        inorderMap.put(inorder[i], i);
    }
    return build(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1, inorderMap);
}

private TreeNode build(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd, Map<Integer, Integer> inorderMap) {
    if (preStart > preEnd) return null;
    
    TreeNode root = new TreeNode(preorder[preStart]);
    int rootIndex = inorderMap.get(preorder[preStart]);
    int leftSize = rootIndex - inStart;
    
    root.left = build(preorder, preStart + 1, preStart + leftSize, inorder, inStart, rootIndex - 1, inorderMap);
    root.right = build(preorder, preStart + leftSize + 1, preEnd, inorder, rootIndex + 1, inEnd, inorderMap);
    
    return root;
}
```

**思路：** 前序第一个是根，在中序中找到根的位置来划分左右子树。

### 从中序和后序构造二叉树（106）

```java
public TreeNode buildTree(int[] inorder, int[] postorder) {
    Map<Integer, Integer> inorderMap = new HashMap<>();
    for (int i = 0; i < inorder.length; i++) {
        inorderMap.put(inorder[i], i);
    }
    return build(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1, inorderMap);
}

private TreeNode build(int[] inorder, int inStart, int inEnd, int[] postorder, int postStart, int postEnd, Map<Integer, Integer> inorderMap) {
    if (inStart > inEnd) return null;
    
    TreeNode root = new TreeNode(postorder[postEnd]);
    int rootIndex = inorderMap.get(postorder[postEnd]);
    int leftSize = rootIndex - inStart;
    
    root.left = build(inorder, inStart, rootIndex - 1, postorder, postStart, postStart + leftSize - 1, inorderMap);
    root.right = build(inorder, rootIndex + 1, inEnd, postorder, postStart + leftSize, postEnd - 1, inorderMap);
    
    return root;
}
```

**思路：** 后序最后一个是根，在中序中找到根的位置来划分左右子树。

### 最大二叉树（654）

```java
public TreeNode constructMaximumBinaryTree(int[] nums) {
    return build(nums, 0, nums.length - 1);
}

private TreeNode build(int[] nums, int left, int right) {
    if (left > right) return null;
    
    int maxIndex = left;
    for (int i = left + 1; i <= right; i++) {
        if (nums[i] > nums[maxIndex]) {
            maxIndex = i;
        }
    }
    
    TreeNode root = new TreeNode(nums[maxIndex]);
    root.left = build(nums, left, maxIndex - 1);
    root.right = build(nums, maxIndex + 1, right);
    
    return root;
}
```

**思路：** 找到最大值作为根，左边构建左子树，右边构建右子树。

## 3. 二叉树属性

### 二叉树最大深度（104）

```java
public int maxDepth(TreeNode root) {
    if (root == null) return 0;
    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
}
```

**思路：** 递归计算左右子树深度的最大值加1。

### 二叉树最小深度（111）

```java
public int minDepth(TreeNode root) {
    if (root == null) return 0;
    if (root.left == null && root.right == null) return 1;
    
    int leftDepth = root.left != null ? minDepth(root.left) : Integer.MAX_VALUE;
    int rightDepth = root.right != null ? minDepth(root.right) : Integer.MAX_VALUE;
    
    return Math.min(leftDepth, rightDepth) + 1;
}
```

**思路：** 叶子节点深度为1，非空子树深度的最小值加1。

### 完全二叉树节点个数（222）

```java
public int countNodes(TreeNode root) {
    if (root == null) return 0;
    
    int leftDepth = getDepth(root.left);
    int rightDepth = getDepth(root.right);
    
    if (leftDepth == rightDepth) {
        return (1 << leftDepth) + countNodes(root.right);
    } else {
        return (1 << rightDepth) + countNodes(root.left);
    }
}

private int getDepth(TreeNode node) {
    int depth = 0;
    while (node != null) {
        node = node.left;
        depth++;
    }
    return depth;
}
```

**思路：** 利用完全二叉树性质，比较左右子树深度来确定哪边是满二叉树。

### 平衡二叉树（110）

```java
public boolean isBalanced(TreeNode root) {
    return getHeight(root) != -1;
}

private int getHeight(TreeNode node) {
    if (node == null) return 0;
    
    int leftHeight = getHeight(node.left);
    if (leftHeight == -1) return -1;
    
    int rightHeight = getHeight(node.right);
    if (rightHeight == -1) return -1;
    
    if (Math.abs(leftHeight - rightHeight) > 1) return -1;
    
    return Math.max(leftHeight, rightHeight) + 1;
}
```

**思路：** 递归计算高度，若左右子树高度差超过1则返回-1表示不平衡。

### 二叉树直径（543）

```java
int maxDiameter = 0;

public int diameterOfBinaryTree(TreeNode root) {
    maxDepth(root);
    return maxDiameter;
}

private int maxDepth(TreeNode node) {
    if (node == null) return 0;
    
    int leftDepth = maxDepth(node.left);
    int rightDepth = maxDepth(node.right);
    
    maxDiameter = Math.max(maxDiameter, leftDepth + rightDepth);
    
    return Math.max(leftDepth, rightDepth) + 1;
}
```

**思路：** 直径是任意两点间最长路径，等于某节点左右子树深度之和的最大值。

## 4. 二叉树路径问题

### 二叉树路径总和（112）

```java
public boolean hasPathSum(TreeNode root, int targetSum) {
    if (root == null) return false;
    
    if (root.left == null && root.right == null) {
        return root.val == targetSum;
    }
    
    return hasPathSum(root.left, targetSum - root.val) || 
           hasPathSum(root.right, targetSum - root.val);
}
```

**思路：** 递归检查到叶子节点时剩余目标值是否等于叶子节点值。

### 路径总和II（113）

```java
public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
    List<List<Integer>> result = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    dfs(root, targetSum, path, result);
    return result;
}

private void dfs(TreeNode node, int targetSum, List<Integer> path, List<List<Integer>> result) {
    if (node == null) return;
    
    path.add(node.val);
    
    if (node.left == null && node.right == null && node.val == targetSum) {
        result.add(new ArrayList<>(path));
    } else {
        dfs(node.left, targetSum - node.val, path, result);
        dfs(node.right, targetSum - node.val, path, result);
    }
    
    path.remove(path.size() - 1);
}
```

**思路：** 回溯法记录路径，到叶子节点时检查是否满足条件并保存路径。

### 路径总和III（437）

```java
public int pathSum(TreeNode root, int targetSum) {
    if (root == null) return 0;
    
    return pathSumFrom(root, targetSum) + 
           pathSum(root.left, targetSum) + 
           pathSum(root.right, targetSum);
}

private int pathSumFrom(TreeNode node, long targetSum) {
    if (node == null) return 0;
    
    int count = 0;
    if (node.val == targetSum) count++;
    
    count += pathSumFrom(node.left, targetSum - node.val);
    count += pathSumFrom(node.right, targetSum - node.val);
    
    return count;
}
```

**思路：** 对每个节点计算以它为起点的路径数，加上左右子树的总路径数。

### 二叉树最大路径和（124）

```java
int maxSum = Integer.MIN_VALUE;

public int maxPathSum(TreeNode root) {
    maxGain(root);
    return maxSum;
}

private int maxGain(TreeNode node) {
    if (node == null) return 0;
    
    int leftGain = Math.max(maxGain(node.left), 0);
    int rightGain = Math.max(maxGain(node.right), 0);
    
    int currentMax = node.val + leftGain + rightGain;
    maxSum = Math.max(maxSum, currentMax);
    
    return node.val + Math.max(leftGain, rightGain);
}
```

**思路：** 对每个节点计算通过它的最大路径和，返回包含该节点的单边最大路径和。

## 5. 二叉搜索树

### 验证二叉搜索树（98）

```java
public boolean isValidBST(TreeNode root) {
    return validate(root, null, null);
}

private boolean validate(TreeNode node, Integer lower, Integer upper) {
    if (node == null) return true;
    
    if ((lower != null && node.val <= lower) || (upper != null && node.val >= upper)) {
        return false;
    }
    
    return validate(node.left, lower, node.val) && validate(node.right, node.val, upper);
}
```

**思路：** 递归验证每个节点值是否在合法范围内，左子树上界是当前值，右子树下界是当前值。

### 二叉搜索树中的搜索（700）

```java
public TreeNode searchBST(TreeNode root, int val) {
    if (root == null || root.val == val) return root;
    
    return val < root.val ? searchBST(root.left, val) : searchBST(root.right, val);
}
```

**思路：** 利用BST性质，小于根值往左找，大于根值往右找。

### 插入到二叉搜索树（701）

```java
public TreeNode insertIntoBST(TreeNode root, int val) {
    if (root == null) return new TreeNode(val);
    
    if (val < root.val) {
        root.left = insertIntoBST(root.left, val);
    } else {
        root.right = insertIntoBST(root.right, val);
    }
    
    return root;
}
```

**思路：** 找到空位置插入新节点，小于当前值插入左子树，否则插入右子树。

### 删除二叉搜索树中的节点（450）

```java
public TreeNode deleteNode(TreeNode root, int key) {
    if (root == null) return null;
    
    if (key < root.val) {
        root.left = deleteNode(root.left, key);
    } else if (key > root.val) {
        root.right = deleteNode(root.right, key);
    } else {
        if (root.left == null) return root.right;
        if (root.right == null) return root.left;
        
        TreeNode minNode = findMin(root.right);
        root.val = minNode.val;
        root.right = deleteNode(root.right, minNode.val);
    }
    
    return root;
}

private TreeNode findMin(TreeNode node) {
    while (node.left != null) {
        node = node.left;
    }
    return node;
}
```

**思路：** 找到节点后分情况处理：无子节点直接删除，一个子节点用子节点替换，两个子节点用右子树最小值替换。

## 6. 公共祖先问题

### 二叉树最近公共祖先（236）

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null || root == p || root == q) return root;
    
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    
    if (left != null && right != null) return root;
    return left != null ? left : right;
}
```

**思路：** 递归查找，如果左右子树都找到目标节点则当前节点是LCA，否则返回找到节点的那一边。

### 二叉搜索树最近公共祖先（235）

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null) return null;
    
    if (root.val > p.val && root.val > q.val) {
        return lowestCommonAncestor(root.left, p, q);
    } else if (root.val < p.val && root.val < q.val) {
        return lowestCommonAncestor(root.right, p, q);
    } else {
        return root;
    }
}
```

**思路：** 利用BST性质，如果两节点都在左边就往左找，都在右边就往右找，否则当前节点就是LCA。

## 7. 修改二叉树结构

### 翻转二叉树（226）

```java
public TreeNode invertTree(TreeNode root) {
    if (root == null) return null;
    
    TreeNode temp = root.left;
    root.left = root.right;
    root.right = temp;
    
    invertTree(root.left);
    invertTree(root.right);
    
    return root;
}
```

**思路：** 递归交换每个节点的左右子树。

### 合并二叉树（617）

```java
public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
    if (root1 == null) return root2;
    if (root2 == null) return root1;
    
    TreeNode merged = new TreeNode(root1.val + root2.val);
    merged.left = mergeTrees(root1.left, root2.left);
    merged.right = mergeTrees(root1.right, root2.right);
    
    return merged;
}
```

**思路：** 递归合并对应位置的节点，节点值相加，空节点用另一个节点替代。

### 修剪二叉搜索树（669）

```java
public TreeNode trimBST(TreeNode root, int low, int high) {
    if (root == null) return null;
    
    if (root.val < low) {
        return trimBST(root.right, low, high);
    } else if (root.val > high) {
        return trimBST(root.left, low, high);
    } else {
        root.left = trimBST(root.left, low, high);
        root.right = trimBST(root.right, low, high);
        return root;
    }
}
```

**思路：** 小于下界往右子树找，大于上界往左子树找，在范围内则递归修剪左右子树。

## 8. 特殊二叉树问题

### 对称二叉树（101）

```java
public boolean isSymmetric(TreeNode root) {
    return isMirror(root, root);
}

private boolean isMirror(TreeNode t1, TreeNode t2) {
    if (t1 == null && t2 == null) return true;
    if (t1 == null || t2 == null) return false;
    
    return t1.val == t2.val && 
           isMirror(t1.right, t2.left) && 
           isMirror(t1.left, t2.right);
}
```

**思路：** 递归比较左子树的右子树和右子树的左子树是否镜像对称。

### 相同的树（100）

```java
public boolean isSameTree(TreeNode p, TreeNode q) {
    if (p == null && q == null) return true;
    if (p == null || q == null) return false;
    
    return p.val == q.val && 
           isSameTree(p.left, q.left) && 
           isSameTree(p.right, q.right);
}
```

**思路：** 递归比较对应节点的值和结构是否相同。

### 子树（572）

```java
public boolean isSubtree(TreeNode root, TreeNode subRoot) {
    if (root == null) return false;
    
    return isSameTree(root, subRoot) || 
           isSubtree(root.left, subRoot) || 
           isSubtree(root.right, subRoot);
}

private boolean isSameTree(TreeNode s, TreeNode t) {
    if (s == null && t == null) return true;
    if (s == null || t == null) return false;
    
    return s.val == t.val && 
           isSameTree(s.left, t.left) && 
           isSameTree(s.right, t.right);
}
```

**思路：** 检查当前节点是否与子树相同，或者在左右子树中递归查找。

这些问题覆盖了二叉树的主要类型和解法模式，掌握这些基本模式可以解决大部分二叉树相关问题。

找到具有 3 个许可证类型的类似代码
