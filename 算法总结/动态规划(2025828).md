## 1. 线性DP

### 1.1 基础线性DP

**70. 爬楼梯**

```java
public int climbStairs(int n) {
    if (n <= 2) return n;
    int prev2 = 1, prev1 = 2;
    for (int i = 3; i <= n; i++) {
        int curr = prev1 + prev2;
        prev2 = prev1;
        prev1 = curr;
    }
    return prev1;
}
```

*思路：每一步可以由前一步或前两步到达，状态转移方程 dp[i] = dp[i-1] + dp[i-2]*

**198. 打家劫舍**

```java
public int rob(int[] nums) {
    int prev2 = 0, prev1 = 0;
    for (int num : nums) {
        int curr = Math.max(prev1, prev2 + num);
        prev2 = prev1;
        prev1 = curr;
    }
    return prev1;
}
```

*思路：每个房子可以选择偷或不偷，偷当前房子就不能偷前一个，状态转移考虑两种情况的最大值*

**213. 打家劫舍 II**

```java
public int rob(int[] nums) {
    if (nums.length == 1) return nums[0];
    return Math.max(robRange(nums, 0, nums.length - 2), 
                   robRange(nums, 1, nums.length - 1));
}
private int robRange(int[] nums, int start, int end) {
    int prev2 = 0, prev1 = 0;
    for (int i = start; i <= end; i++) {
        int curr = Math.max(prev1, prev2 + nums[i]);
        prev2 = prev1;
        prev1 = curr;
    }
    return prev1;
}
```

*思路：环形数组分为两种情况：偷第一个不偷最后一个，或偷最后一个不偷第一个*

**300. 最长递增子序列**

```java
public int lengthOfLIS(int[] nums) {
    int[] dp = new int[nums.length];
    Arrays.fill(dp, 1);
    int maxLen = 1;
    for (int i = 1; i < nums.length; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[i] > nums[j]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
        maxLen = Math.max(maxLen, dp[i]);
    }
    return maxLen;
}
```

*思路：dp[i]表示以nums[i]结尾的最长递增子序列长度，遍历前面所有小于当前元素的位置更新*

### 1.2 字符串DP

**5. 最长回文子串**

```java
public String longestPalindrome(String s) {
    int n = s.length();
    boolean[][] dp = new boolean[n][n];
    int start = 0, maxLen = 1;
    
    for (int i = 0; i < n; i++) dp[i][i] = true;
    
    for (int len = 2; len <= n; len++) {
        for (int i = 0; i <= n - len; i++) {
            int j = i + len - 1;
            if (s.charAt(i) == s.charAt(j)) {
                dp[i][j] = (len == 2) || dp[i + 1][j - 1];
                if (dp[i][j] && len > maxLen) {
                    start = i;
                    maxLen = len;
                }
            }
        }
    }
    return s.substring(start, start + maxLen);
}
```

*==思路：dp[i][j]表示s[i..j]是否为回文，当两端字符相等时取决于内部子串是否为回文==*

**1143. 最长公共子序列**

```java
public int longestCommonSubsequence(String text1, String text2) {
    int m = text1.length(), n = text2.length();
    int[][] dp = new int[m + 1][n + 1];
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[m][n];
}
```

*思路：字符相等时长度加1，不等时取删除其中一个字符后的最大值*

**72. 编辑距离**

```java
public int minDistance(String word1, String word2) {
    int m = word1.length(), n = word2.length();
    int[][] dp = new int[m + 1][n + 1];
    
    for (int i = 0; i <= m; i++) dp[i][0] = i;
    for (int j = 0; j <= n; j++) dp[0][j] = j;
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = Math.min(dp[i - 1][j - 1], 
                          Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;
            }
        }
    }
    return dp[m][n];
}
```

*思路：字符相等时不需操作，不等时考虑替换、删除、插入三种操作的最小值*

## 2. 背包问题

### 2.1 0-1背包

**416. 分割等和子集**

```java
public boolean canPartition(int[] nums) {
    int sum = Arrays.stream(nums).sum();
    if (sum % 2 != 0) return false;
    
    int target = sum / 2;
    boolean[] dp = new boolean[target + 1];
    dp[0] = true;
    
    for (int num : nums) {
        for (int j = target; j >= num; j--) {
            dp[j] = dp[j] || dp[j - num];
        }
    }
    return dp[target];
}
```

*思路：转化为0-1背包问题，判断是否能从数组中选择元素组成总和的一半*

**494. 目标和**

```java
public int findTargetSumWays(int[] nums, int target) {
    int sum = Arrays.stream(nums).sum();
    if ((target + sum) % 2 != 0 || Math.abs(target) > sum) return 0;
    
    int bagSize = (target + sum) / 2;
    int[] dp = new int[bagSize + 1];
    dp[0] = 1;
    
    for (int num : nums) {
        for (int j = bagSize; j >= num; j--) {
            dp[j] += dp[j - num];
        }
    }
    return dp[bagSize];
}
```

*思路：将问题转化为在数组中选择一些数字使其和为(target + sum) / 2的方案数*

### 2.2 完全背包

**322. 零钱兑换**

```java
public int coinChange(int[] coins, int amount) {
    int[] dp = new int[amount + 1];
    Arrays.fill(dp, amount + 1);
    dp[0] = 0;
    
    for (int coin : coins) {
        for (int j = coin; j <= amount; j++) {
            dp[j] = Math.min(dp[j], dp[j - coin] + 1);
        }
    }
    return dp[amount] > amount ? -1 : dp[amount];
}
```

*思路：完全背包问题，每个硬币可以使用多次，求组成目标金额的最少硬币数*

**518. 零钱兑换 II**

```java
public int change(int amount, int[] coins) {
    int[] dp = new int[amount + 1];
    dp[0] = 1;
    
    for (int coin : coins) {
        for (int j = coin; j <= amount; j++) {
            dp[j] += dp[j - coin];
        }
    }
    return dp[amount];
}
```

*思路：求组成目标金额的方案数，外层遍历硬币避免重复计算不同顺序的组合*

## 3. 区间DP

**516. 最长回文子序列**

```java
public int longestPalindromeSubseq(String s) {
    int n = s.length();
    int[][] dp = new int[n][n];
    
    for (int i = 0; i < n; i++) dp[i][i] = 1;
    
    for (int len = 2; len <= n; len++) {
        for (int i = 0; i <= n - len; i++) {
            int j = i + len - 1;
            if (s.charAt(i) == s.charAt(j)) {
                dp[i][j] = dp[i + 1][j - 1] + 2;
            } else {
                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[0][n - 1];
}
// 其余解法：枚举中心点
```

*思路：区间DP，两端字符相等时长度加2，不等时取去掉一端字符后的最大值*

**312. 戳气球**

```java
public int maxCoins(int[] nums) {
    int n = nums.length;
    int[] arr = new int[n + 2];
    arr[0] = arr[n + 1] = 1;
    for (int i = 0; i < n; i++) arr[i + 1] = nums[i];
    
    int[][] dp = new int[n + 2][n + 2];
    
    for (int len = 3; len <= n + 2; len++) {
        for (int i = 0; i <= n + 2 - len; i++) {
            int j = i + len - 1;
            for (int k = i + 1; k < j; k++) {
                dp[i][j] = Math.max(dp[i][j], 
                          dp[i][k] + dp[k][j] + arr[i] * arr[k] * arr[j]);
            }
        }
    }
    // for (int l = n - 1; l >= 0; l--) {
    //     for (int r = l + 2; r <= n + 1; r++) {  // 注意这里改为n+1
    //         for (int k = l + 1; k < r; k++) {
    //             int curScore = arr[l] * arr[k] * arr[r];     // 修正1
    //             curScore += dp[l][k] + dp[k][r];             // 修正2
    //             dp[l][r] = Math.max(dp[l][r], curScore);
    //         }
    //     }
    // }
    return dp[0][n + 1];
}
```

*思路：逆向思维，考虑最后戳破哪个气球，将问题分解为左右两个子区间*

## 4. 状态机DP

**121. 买卖股票的最佳时机**

```java
public int maxProfit(int[] prices) {
    int minPrice = Integer.MAX_VALUE;
    int maxProfit = 0;
    
    for (int price : prices) {
        if (price < minPrice) {
            minPrice = price;
        } else if (price - minPrice > maxProfit) {
            maxProfit = price - minPrice;
        }
    }
    return maxProfit;
}
```

*思路：维护到目前为止的最低价格，计算当前价格卖出的最大利润*

**122. 买卖股票的最佳时机 II**

```java
public int maxProfit(int[] prices) {
    int hold = -prices[0], sold = 0;
    
    for (int i = 1; i < prices.length; i++) {
        int newHold = Math.max(hold, sold - prices[i]);
        int newSold = Math.max(sold, hold + prices[i]);
        hold = newHold;
        sold = newSold;
    }
    return sold;
}
```

*思路：状态机DP，维护持有股票和不持有股票两种状态的最大收益*

**123. 买卖股票的最佳时机 III**

```java
public int maxProfit(int[] prices) {
    int buy1 = -prices[0], sell1 = 0;
    int buy2 = -prices[0], sell2 = 0;
    
    for (int i = 1; i < prices.length; i++) {
        buy1 = Math.max(buy1, -prices[i]);
        sell1 = Math.max(sell1, buy1 + prices[i]);
        buy2 = Math.max(buy2, sell1 - prices[i]);
        sell2 = Math.max(sell2, buy2 + prices[i]);
    }
    return sell2;
}
```

*思路：维护两次交易的四个状态：第一次买入、第一次卖出、第二次买入、第二次卖出*

## 5. 树形DP

**337. 打家劫舍 III**

```java
public int rob(TreeNode root) {
    int[] result = dfs(root);
    return Math.max(result[0], result[1]);
}

private int[] dfs(TreeNode node) {
    if (node == null) return new int[]{0, 0};
    
    int[] left = dfs(node.left);
    int[] right = dfs(node.right);
    
    int rob = node.val + left[1] + right[1];
    int notRob = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
    
    return new int[]{rob, notRob};
}
```

*思路：对每个节点维护偷和不偷两种状态，偷当前节点就不能偷子节点*

## 6. 数位DP

**233. 数字1的个数**

```java
public int countDigitOne(int n) {
    int count = 0;
    for (long digit = 1; digit <= n; digit *= 10) {
        long divider = digit * 10;
        count += (n / divider) * digit + 
                Math.min(Math.max(n % divider - digit + 1, 0), digit);
    }
    return count;
}
```

*思路：按位统计，对每一位分别计算在该位置上出现1的次数*

## 7. 计数DP

**62. 不同路径**

```java
public int uniquePaths(int m, int n) {
    int[] dp = new int[n];
    Arrays.fill(dp, 1);
    
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[j] += dp[j - 1];
        }
    }
    return dp[n - 1];
}
```

*思路：每个位置只能从上方或左方到达，路径数为两个方向路径数之和*

**63. 不同路径 II**

```java
public int uniquePathsWithObstacles(int[][] obstacleGrid) {
    int m = obstacleGrid.length, n = obstacleGrid[0].length;
    int[] dp = new int[n];
    dp[0] = obstacleGrid[0][0] == 0 ? 1 : 0;
    
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (obstacleGrid[i][j] == 1) {
                dp[j] = 0;
            } else if (j > 0) {
                dp[j] += dp[j - 1];
            }
        }
    }
    return dp[n - 1];
}
```

*思路：在基础路径问题上增加障碍物判断，遇到障碍物时路径数为0*

## 8. 概率DP

**688. 骑士在棋盘上的概率**

```java
public double knightProbability(int n, int k, int row, int column) {
    double[][][] dp = new double[k + 1][n][n];
    int[][] dirs = {{-2,-1},{-2,1},{-1,-2},{-1,2},{1,-2},{1,2},{2,-1},{2,1}};
    
    dp[0][row][column] = 1.0;
    
    for (int step = 1; step <= k; step++) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                for (int[] dir : dirs) {
                    int prevI = i - dir[0], prevJ = j - dir[1];
                    if (prevI >= 0 && prevI < n && prevJ >= 0 && prevJ < n) {
                        dp[step][i][j] += dp[step - 1][prevI][prevJ] / 8.0;
                    }
                }
            }
        }
    }
    
    double result = 0.0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            result += dp[k][i][j];
        }
    }
    return result;
}
```

*思路：维护每步后在棋盘各位置的概率，最终求和得到留在棋盘上的总概率*

### 总结

这些是力扣中最常见的动态规划问题类型，掌握了这些模式和解题思路，就能应对大部分动态规划题目。关键是要理解状态定义、状态转移方程和边界条件。

1. 确定问题最优解能否由子问题最优解推导出来。
2. 确定dp数组含义以及初始化。
   - 关于定义dp数组长度：看边界需求：如果需要用 dp[0] 表示有意义的初始状态（如空集、起点），就用 n+1。如果 dp[i] 直接对应输入数组的第 i 个元素，就用 n。
3. 确定状态转移方程。
4. 根据状态转移方程优化空间。

关于背包问题中遍历顺序：采用先物品再背包容量即可，如果采用了空间压缩，对于0-1背包要从大到小遍历容量（确保每个问题只用一次）。对于完全背包要按容量从小到大遍历，这样对于一个物体就考虑了重复放入大情况。

对于排列问题（需要考虑物品顺序）

先遍历容量再遍历物品

```
// 377. 组合总和 Ⅳ（排列数）
public int combinationSum4(int[] nums, int target) {
    int[] dp = new int[target + 1];
    dp[0] = 1;
    
    // 先遍历背包
    for (int j = 1; j <= target; j++) {
        // 再遍历物品
        for (int num : nums) {
            if (j >= num) {
                dp[j] += dp[j - num];
            }
        }
    }
    return dp[target];
}
```

}