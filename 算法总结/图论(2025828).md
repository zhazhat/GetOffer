# 力扣图论问题分类总结

## 1. 图的遍历（DFS/BFS）

### 1.1 岛屿问题

**200. 岛屿数量**

```java
public int numIslands(char[][] grid) {
    if (grid == null || grid.length == 0) return 0;
    
    int count = 0;
    for (int i = 0; i < grid.length; i++) {
        for (int j = 0; j < grid[0].length; j++) {
            if (grid[i][j] == '1') {
                dfs(grid, i, j);
                count++;
            }
        }
    }
    return count;
}

private void dfs(char[][] grid, int i, int j) {
    if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] != '1') {
        return;
    }
    grid[i][j] = '0'; // 标记为已访问
    dfs(grid, i + 1, j);
    dfs(grid, i - 1, j);
    dfs(grid, i, j + 1);
    dfs(grid, i, j - 1);
}
```

*思路：遇到未访问的陆地就开始DFS，将整个岛屿标记为已访问，每次DFS完成就找到一个岛屿*

统计封闭岛屿：先淹没边缘岛屿在计算一遍。

**695. 岛屿的最大面积**

```java
public int maxAreaOfIsland(int[][] grid) {
    int maxArea = 0;
    for (int i = 0; i < grid.length; i++) {
        for (int j = 0; j < grid[0].length; j++) {
            if (grid[i][j] == 1) {
                maxArea = Math.max(maxArea, dfs(grid, i, j));
            }
        }
    }
    return maxArea;
}

private int dfs(int[][] grid, int i, int j) {
    if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] != 1) {
        return 0;
    }
    grid[i][j] = 0;
    return 1 + dfs(grid, i + 1, j) + dfs(grid, i - 1, j) + 
           dfs(grid, i, j + 1) + dfs(grid, i, j - 1);
}
```

*思路：DFS遍历岛屿时累计面积，返回当前岛屿的总面积*

### 1.2 路径搜索

**994. 腐烂的橘子**

```java
public int orangesRotting(int[][] grid) {
    Queue<int[]> queue = new LinkedList<>();
    int freshCount = 0;
    
    // 找到所有腐烂的橘子作为起点
    for (int i = 0; i < grid.length; i++) {
        for (int j = 0; j < grid[0].length; j++) {
            if (grid[i][j] == 2) {
                queue.offer(new int[]{i, j});
            } else if (grid[i][j] == 1) {
                freshCount++;
            }
        }
    }
    
    if (freshCount == 0) return 0;
    
    int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    int minutes = 0;
    
    while (!queue.isEmpty()) {
        int size = queue.size();
        for (int i = 0; i < size; i++) {
            int[] curr = queue.poll();
            for (int[] dir : dirs) {
                int x = curr[0] + dir[0];
                int y = curr[1] + dir[1];
                if (x >= 0 && x < grid.length && y >= 0 && y < grid[0].length && grid[x][y] == 1) {
                    grid[x][y] = 2;
                    freshCount--;
                    queue.offer(new int[]{x, y});
                }
            }
        }
        if (!queue.isEmpty()) minutes++;
    }
    
    return freshCount == 0 ? minutes : -1;
}
```

*思路：多源BFS，从所有腐烂橘子同时开始扩散，按层次遍历计算时间*

## 2. 拓扑排序

**207. 课程表**

```java
public boolean canFinish(int numCourses, int[][] prerequisites) {
    int[] indegree = new int[numCourses];
    List<List<Integer>> graph = new ArrayList<>();
    
    for (int i = 0; i < numCourses; i++) {
        graph.add(new ArrayList<>());
    }
    
    // 建图和计算入度
    for (int[] pre : prerequisites) {
        graph.get(pre[1]).add(pre[0]);
        indegree[pre[0]]++;
    }
    
    Queue<Integer> queue = new LinkedList<>();
    for (int i = 0; i < numCourses; i++) {
        if (indegree[i] == 0) {
            queue.offer(i);
        }
    }
    
    int count = 0;
    while (!queue.isEmpty()) {
        int course = queue.poll();
        count++;
        for (int next : graph.get(course)) {
            indegree[next]--;
            if (indegree[next] == 0) {
                queue.offer(next);
            }
        }
    }
    
    return count == numCourses;
}
```

*思路：使用Kahn算法，从入度为0的节点开始，逐步移除边，检查是否能处理完所有课程*

**210. 课程表 II**

```java
public int[] findOrder(int numCourses, int[][] prerequisites) {
    int[] indegree = new int[numCourses];
    List<List<Integer>> graph = new ArrayList<>();
    
    for (int i = 0; i < numCourses; i++) {
        graph.add(new ArrayList<>());
    }
    
    for (int[] pre : prerequisites) {
        graph.get(pre[1]).add(pre[0]);
        indegree[pre[0]]++;
    }
    
    Queue<Integer> queue = new LinkedList<>();
    for (int i = 0; i < numCourses; i++) {
        if (indegree[i] == 0) {
            queue.offer(i);
        }
    }
    
    int[] result = new int[numCourses];
    int index = 0;
    
    while (!queue.isEmpty()) {
        int course = queue.poll();
        result[index++] = course;
        for (int next : graph.get(course)) {
            indegree[next]--;
            if (indegree[next] == 0) {
                queue.offer(next);
            }
        }
    }
    
    return index == numCourses ? result : new int[0];
}
```

*思路：在课程表I的基础上，记录拓扑排序的具体顺序*

## 3. 并查集

**547. 省份数量**

```java
class UnionFind {
    int[] parent;
    int[] rank;
    int count;
    
    public UnionFind(int n) {
        parent = new int[n];
        rank = new int[n];
        count = n;
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }
    
    public int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]); // 路径压缩
        }
        return parent[x];
    }
    
    public void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            if (rank[rootX] < rank[rootY]) {
                parent[rootX] = rootY;
            } else if (rank[rootX] > rank[rootY]) {
                parent[rootY] = rootX;
            } else {
                parent[rootY] = rootX;
                rank[rootX]++;
            }
            count--;
        }
    }
}

public int findCircleNum(int[][] isConnected) {
    int n = isConnected.length;
    UnionFind uf = new UnionFind(n);
    
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (isConnected[i][j] == 1) {
                uf.union(i, j);
            }
        }
    }
    
    return uf.count;
}
```

*思路：将相互连接的城市合并到同一个集合中，最终集合数量就是省份数量*

**684. 冗余连接**

```java
public int[] findRedundantConnection(int[][] edges) {
    UnionFind uf = new UnionFind(edges.length + 1);
    
    for (int[] edge : edges) {
        if (uf.find(edge[0]) == uf.find(edge[1])) {
            return edge; // 找到环
        }
        uf.union(edge[0], edge[1]);
    }
    
    return new int[0];
}
```

*思路：逐个添加边，当两个节点已经连通时再添加边就会形成环，返回这条边*

## 4. 最短路径

### 4.1 Dijkstra算法

**743. 网络延迟时间**

```java
public int networkDelayTime(int[][] times, int n, int k) {
    // 建图
    List<List<int[]>> graph = new ArrayList<>();
    for (int i = 0; i <= n; i++) {
        graph.add(new ArrayList<>());
    }
    
    for (int[] time : times) {
        graph.get(time[0]).add(new int[]{time[1], time[2]});
    }
    
    // Dijkstra算法
    int[] dist = new int[n + 1];
    Arrays.fill(dist, Integer.MAX_VALUE);
    dist[k] = 0;
    
    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);
    pq.offer(new int[]{k, 0});
    
    while (!pq.isEmpty()) {
        int[] curr = pq.poll();
        int node = curr[0];
        int time = curr[1];
        
        if (time > dist[node]) continue;
        
        for (int[] neighbor : graph.get(node)) {
            int next = neighbor[0];
            int weight = neighbor[1];
            if (dist[node] + weight < dist[next]) {
                dist[next] = dist[node] + weight;
                pq.offer(new int[]{next, dist[next]});
            }
        }
    }
    
    int maxTime = 0;
    for (int i = 1; i <= n; i++) {
        if (dist[i] == Integer.MAX_VALUE) return -1;
        maxTime = Math.max(maxTime, dist[i]);
    }
    
    return maxTime;
}
```

*思路：使用Dijkstra算法求从起点到所有节点的最短路径，返回最大的最短路径*

### 4.2 BFS最短路径

**127. 单词接龙**

```java
public int ladderLength(String beginWord, String endWord, List<String> wordList) {
    Set<String> wordSet = new HashSet<>(wordList);
    if (!wordSet.contains(endWord)) return 0;
    
    Queue<String> queue = new LinkedList<>();
    queue.offer(beginWord);
    int level = 1;
    
    while (!queue.isEmpty()) {
        int size = queue.size();
        for (int i = 0; i < size; i++) {
            String word = queue.poll();
            if (word.equals(endWord)) return level;
            
            char[] chars = word.toCharArray();
            for (int j = 0; j < chars.length; j++) {
                char original = chars[j];
                for (char c = 'a'; c <= 'z'; c++) {
                    if (c == original) continue;
                    chars[j] = c;
                    String newWord = new String(chars);
                    if (wordSet.contains(newWord)) {
                        queue.offer(newWord);
                        wordSet.remove(newWord); // 避免重复访问
                    }
                }
                chars[j] = original;
            }
        }
        level++;
    }
    
    return 0;
}
```

*思路：BFS逐层搜索，每次改变一个字符生成新单词，直到找到目标单词*

## 5. 最小生成树

**1584. 连接所有点的最小费用**

```java
public int minCostConnectPoints(int[][] points) {
    int n = points.length;
    
    // 生成所有边
    List<int[]> edges = new ArrayList<>();
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            int dist = Math.abs(points[i][0] - points[j][0]) + 
                      Math.abs(points[i][1] - points[j][1]);
            edges.add(new int[]{i, j, dist});
        }
    }
    
    // Kruskal算法
    edges.sort((a, b) -> a[2] - b[2]);
    UnionFind uf = new UnionFind(n);
    
    int cost = 0;
    int edgesUsed = 0;
    
    for (int[] edge : edges) {
        if (uf.find(edge[0]) != uf.find(edge[1])) {
            uf.union(edge[0], edge[1]);
            cost += edge[2];
            edgesUsed++;
            if (edgesUsed == n - 1) break;
        }
    }
    
    return cost;
}
```

*思路：使用Kruskal算法，按边权重排序，用并查集避免环的产生*

## 6. 强连通分量

**1192. 查找集群内的关键连接**

```java
public List<List<Integer>> criticalConnections(int n, List<List<Integer>> connections) {
    List<List<Integer>> graph = new ArrayList<>();
    for (int i = 0; i < n; i++) {
        graph.add(new ArrayList<>());
    }
    
    for (List<Integer> conn : connections) {
        graph.get(conn.get(0)).add(conn.get(1));
        graph.get(conn.get(1)).add(conn.get(0));
    }
    
    int[] disc = new int[n];
    int[] low = new int[n];
    boolean[] visited = new boolean[n];
    List<List<Integer>> result = new ArrayList<>();
    
    dfs(0, -1, graph, disc, low, visited, result, new int[]{0});
    
    return result;
}

private void dfs(int u, int parent, List<List<Integer>> graph, 
                 int[] disc, int[] low, boolean[] visited, 
                 List<List<Integer>> result, int[] time) {
    visited[u] = true;
    disc[u] = low[u] = time[0]++;
    
    for (int v : graph.get(u)) {
        if (v == parent) continue;
        
        if (!visited[v]) {
            dfs(v, u, graph, disc, low, visited, result, time);
            low[u] = Math.min(low[u], low[v]);
            
            // 桥的判断条件
            if (low[v] > disc[u]) {
                result.add(Arrays.asList(u, v));
            }
        } else {
            low[u] = Math.min(low[u], disc[v]);
        }
    }
}
```

*思路：使用Tarjan算法找桥，通过DFS时间戳和回边信息判断关键连接*

## 7. 二分图

**785. 判断二分图**

```java
public boolean isBipartite(int[][] graph) {
    int n = graph.length;
    int[] colors = new int[n];
    
    for (int i = 0; i < n; i++) {
        if (colors[i] == 0) {
            if (!dfs(graph, colors, i, 1)) {
                return false;
            }
        }
    }
    
    return true;
}

private boolean dfs(int[][] graph, int[] colors, int node, int color) {
    colors[node] = color;
    
    for (int neighbor : graph[node]) {
        if (colors[neighbor] == 0) {
            if (!dfs(graph, colors, neighbor, -color)) {
                return false;
            }
        } else if (colors[neighbor] == color) {
            return false;
        }
    }
    
    return true;
}
```

*思路：用DFS给节点染色，相邻节点必须是不同颜色，如果冲突则不是二分图*

## 总结

图论问题的核心在于：

1. **图的表示**：邻接表、邻接矩阵、边列表
2. **遍历算法**：DFS深度优先、BFS广度优先  
3. **特殊算法**：拓扑排序、并查集、最短路径、最小生成树
4. **问题转化**：将实际问题抽象为图论模型

掌握这些基础算法和模板，就能应对力扣中大部分图论问题。关键是要理解每种算法的适用场景和实现细节。